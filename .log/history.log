--[ 2022.11.11.13.15.58.079.0 ]--
NewLogger: P05_KDTrees
Version: 1.5
--[ 2022.11.11.13.15.58.793.0 ]--
InitTree:
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2022.11.11.13.15.58.798.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2022.11.11.13.15.58.798.1 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    // constructor makes empty collection
    public PSBruteForce() { }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return 0; }

    // return whether the KDTree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2022.11.11.13.15.58.799.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2022.11.11.13.15.58.800.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Point(Point p) {
        this.x = p.x;
        this.y = p.y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns a new point that has values added to components
    public Point add(Point p) {
        return add(p.x, p.y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    public boolean isInBounds(Point min, Point max) {
        return isInBounds(min.x, min.y, max.x, max.y);
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2022.11.11.13.15.58.833.0 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSKDTree<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2022.11.11.13.15.58.834.0 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2022.11.11.13.15.58.835.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2022.11.11.13.15.58.836.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.11.13.15.58.836.1 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2022.11.11.13.15.58.837.0 ]--
InitFile: /.cos265


--[ 2022.11.11.13.15.58.837.1 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2022.11.11.13.15.58.837.2 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2022.11.11.13.15.58.837.3 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2022.11.11.13.28.27.633.0 ]--
NewLogger: P05_KDTrees
Version: 1.5
--[ 2022.11.11.13.28.27.906.0 ]--
InitTree:
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.git/info/exclude
/.git/logs/refs/heads/main
/.git/logs/refs/remotes/origin/HEAD
/.git/logs/HEAD
/.git/refs/heads/main
/.git/refs/remotes/origin/HEAD
/.git/hooks/update.sample
/.git/hooks/pre-push.sample
/.git/hooks/commit-msg.sample
/.git/hooks/pre-commit.sample
/.git/hooks/pre-rebase.sample
/.git/hooks/post-update.sample
/.git/hooks/pre-receive.sample
/.git/hooks/applypatch-msg.sample
/.git/hooks/pre-applypatch.sample
/.git/hooks/pre-merge-commit.sample
/.git/hooks/push-to-checkout.sample
/.git/hooks/fsmonitor-watchman.sample
/.git/hooks/prepare-commit-msg.sample
/.git/objects/pack/pack-5320b6e6be866c618967d59f12c11bde247dfe82.idx
/.git/objects/pack/pack-5320b6e6be866c618967d59f12c11bde247dfe82.pack
/.git/HEAD
/.git/index
/.git/config
/.git/description
/.git/packed-refs
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/P05_KDTrees.iml

--[ 2022.11.11.13.28.27.907.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2022.11.11.13.28.27.907.1 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSKDTree<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2022.11.11.13.28.27.907.2 ]--
InitFile: /.cos265


--[ 2022.11.11.13.28.27.907.3 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.11.13.28.27.908.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Point(Point p) {
        this.x = p.x;
        this.y = p.y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns a new point that has values added to components
    public Point add(Point p) {
        return add(p.x, p.y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    public boolean isInBounds(Point min, Point max) {
        return isInBounds(min.x, min.y, max.x, max.y);
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2022.11.11.13.28.27.908.1 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    // constructor makes empty collection
    public PSBruteForce() { }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return 0; }

    // return whether the KDTree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2022.11.11.13.28.27.908.2 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2022.11.11.13.28.27.908.3 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2022.11.11.13.28.27.908.4 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2022.11.11.13.28.27.908.5 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2022.11.11.13.28.27.909.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2022.11.11.13.28.27.909.1 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2022.11.11.13.28.27.909.2 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2022.11.11.13.28.42.015.0 ]--
:/src/PSBruteForce.java
+ 7  
--[ 2022.11.11.13.28.42.081.0 ]--
r 7 
--[ 2022.11.11.13.28.42.123.0 ]--
+ 7 
--[ 2022.11.11.13.28.43.544.0 ]--
+ 7 
--[ 2022.11.11.13.28.56.576.0 ]--
r 8 /
--[ 2022.11.11.13.28.57.099.0 ]--
r 8 /*
--[ 2022.11.11.13.28.58.326.0 ]--
r 8 /
--[ 2022.11.11.13.28.58.714.0 ]--
r 8 //
--[ 2022.11.11.13.28.59.078.0 ]--
r 8 // 
--[ 2022.11.11.13.29.01.020.0 ]--
r 8 // T
--[ 2022.11.11.13.29.01.199.0 ]--
r 8 // Te
--[ 2022.11.11.13.29.01.458.0 ]--
r 8 // Tes
--[ 2022.11.11.13.29.01.665.0 ]--
r 8 // Test
--[ 2022.11.11.13.29.01.756.0 ]--
r 8 // Testi
--[ 2022.11.11.13.29.01.876.0 ]--
r 8 // Testin
--[ 2022.11.11.13.29.01.972.0 ]--
r 8 // Testing
--[ 2022.11.11.13.29.02.066.0 ]--
r 8 // Testing 
--[ 2022.11.11.13.29.06.233.0 ]--
r 8 // Testing G
--[ 2022.11.11.13.29.06.369.0 ]--
r 8 // Testing Gi
--[ 2022.11.11.13.29.06.443.0 ]--
r 8 // Testing Git
--[ 2022.11.11.13.29.07.453.0 ]--
r 8 // Testing Git 
--[ 2022.11.11.13.29.07.646.0 ]--
r 8 // Testing Git -
--[ 2022.11.11.13.29.07.767.0 ]--
r 8 // Testing Git --
--[ 2022.11.11.13.29.08.100.0 ]--
r 8 // Testing Git -- 
--[ 2022.11.11.13.29.08.486.0 ]--
r 8 // Testing Git -- K
--[ 2022.11.11.13.29.08.922.0 ]--
r 8 // Testing Git -- Km
--[ 2022.11.11.13.29.09.096.0 ]--
r 8 // Testing Git -- Kmi
--[ 2022.11.11.13.29.09.251.0 ]--
r 8 // Testing Git -- Kmik
--[ 2022.11.11.13.29.09.520.0 ]--
r 8 // Testing Git -- Kmi
--[ 2022.11.11.13.29.09.647.0 ]--
r 8 // Testing Git -- Km
--[ 2022.11.11.13.29.09.846.0 ]--
r 8 // Testing Git -- K
--[ 2022.11.11.13.29.10.014.0 ]--
r 8 // Testing Git -- 
--[ 2022.11.11.13.29.10.388.0 ]--
r 8 // Testing Git -- k
--[ 2022.11.11.13.29.10.540.0 ]--
r 8 // Testing Git -- km
--[ 2022.11.11.13.29.10.685.0 ]--
r 8 // Testing Git -- kmi
--[ 2022.11.11.13.29.10.853.0 ]--
r 8 // Testing Git -- kmik
--[ 2022.11.11.13.29.10.993.0 ]--
r 8 // Testing Git -- kmike
--[ 2022.11.11.13.29.11.084.0 ]--
r 8 // Testing Git -- kmikel
--[ 2022.11.11.13.29.11.174.0 ]--
r 8 // Testing Git -- kmikels
--[ 2022.11.11.13.31.32.428.0 ]--
NewLogger: P05_KDTrees
Version: 1.5
--[ 2022.11.11.13.31.32.582.0 ]--
InitTree:
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.git/info/exclude
/.git/logs/refs/heads/main
/.git/logs/refs/remotes/origin/HEAD
/.git/logs/refs/remotes/origin/main
/.git/logs/HEAD
/.git/refs/remotes/origin/HEAD
/.git/refs/remotes/origin/main
/.git/hooks/update.sample
/.git/hooks/pre-push.sample
/.git/hooks/commit-msg.sample
/.git/hooks/pre-commit.sample
/.git/hooks/pre-rebase.sample
/.git/hooks/post-update.sample
/.git/hooks/pre-receive.sample
/.git/hooks/applypatch-msg.sample
/.git/hooks/pre-applypatch.sample
/.git/hooks/pre-merge-commit.sample
/.git/hooks/push-to-checkout.sample
/.git/hooks/fsmonitor-watchman.sample
/.git/hooks/prepare-commit-msg.sample
/.git/objects/0d/90a95e4569ab236f012c54a903f79e23f7e45d
/.git/objects/1a/49d62b998226393c172907eef021434d19be9a
/.git/objects/26/3963a64f2a64659282fd9cbe561dd7a5e4a676
/.git/objects/2b/5f9208bfadbbc9019b47a713b74462b9cd2613
/.git/objects/ca/22da9b6c126b0744cfde03b32ebdff29cb41ab
/.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
/.git/objects/d2/e73db08c8563911c081a8651a77f67c4b48b43
/.git/objects/f6/cca8a6084310f182dc287fadbb82c5ebcfffe8
/.git/objects/pack/pack-5320b6e6be866c618967d59f12c11bde247dfe82.idx
/.git/objects/pack/pack-5320b6e6be866c618967d59f12c11bde247dfe82.pack
/.git/HEAD
/.git/index
/.git/config
/.git/description
/.git/packed-refs
/.git/COMMIT_EDITMSG
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2022.11.11.13.31.32.583.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2022.11.11.13.31.32.583.1 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Point(Point p) {
        this.x = p.x;
        this.y = p.y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns a new point that has values added to components
    public Point add(Point p) {
        return add(p.x, p.y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    public boolean isInBounds(Point min, Point max) {
        return isInBounds(min.x, min.y, max.x, max.y);
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2022.11.11.13.31.32.583.2 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2022.11.11.13.31.32.583.3 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2022.11.11.13.31.32.584.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2022.11.11.13.31.32.584.1 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2022.11.11.13.31.32.584.2 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSKDTree<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2022.11.11.13.31.32.584.3 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */

// Testing Git -- kmikels

public class PSBruteForce<Value> implements PointSearch<Value> {
    // constructor makes empty collection
    public PSBruteForce() { }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return 0; }

    // return whether the KDTree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2022.11.11.13.31.32.584.4 ]--
InitFile: /.cos265


--[ 2022.11.11.13.31.32.584.5 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.11.13.31.32.584.6 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2022.11.11.13.31.32.584.7 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2022.11.11.13.31.32.584.8 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2022.11.11.13.33.58.982.0 ]--
:/src/PSKDTree.java
r 7 public class    PSKDTree<Value> implements PointSearch<Value> {
--[ 2022.11.11.13.33.58.983.0 ]--
UpdateTree (AD): 1 0
+ /.git/refs/heads/main

--[ 2022.11.11.13.34.01.151.0 ]--
r 7 public class PSKDTree<Value> implements PointSearch<Value> {
--[ 2022.11.11.13.34.32.937.0 ]--
r 7 public class    PSKDTree<Value> implements PointSearch<Value> {
--[ 2022.11.11.13.34.34.150.0 ]--
r 7 public class PSKDTree<Value> implements PointSearch<Value> {
--[ 2022.11.11.13.34.56.681.0 ]--
UpdateTree (AD): 23 0
+ /out/production/P05_KDTrees/.donotlog
+ /out/production/P05_KDTrees/algs4.jar
+ /out/production/P05_KDTrees/stdlib.jar
+ /out/production/P05_KDTrees/input1M.txt
+ /out/production/P05_KDTrees/Mouse.class
+ /out/production/P05_KDTrees/Point.class
+ /out/production/P05_KDTrees/input100K.txt
+ /out/production/P05_KDTrees/Point$1.class
+ /out/production/P05_KDTrees/Point$2.class
+ /out/production/P05_KDTrees/Point$3.class
+ /out/production/P05_KDTrees/Point$4.class
+ /out/production/P05_KDTrees/burgerking.csv
+ /out/production/P05_KDTrees/KeyPress.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/Partition.class
+ /out/production/P05_KDTrees/PointDist.class
+ /out/production/P05_KDTrees/Visualizer.class
+ /out/production/P05_KDTrees/PointSearch.class
+ /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class
+ /out/production/P05_KDTrees/FastFoodVisualizer.class
+ /out/production/P05_KDTrees/Partition$Direction.class
+ /out/production/P05_KDTrees/NearestNeighborVisualizer.class

--[ 2022.11.11.13.34.56.682.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.11.13.37.22.036.0 ]--
UpdateTree (AD): 1 0
+ /.idea/workspace.xml

--[ 2022.11.11.13.37.22.036.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.11.13.38.59.074.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.11.13.42.55.240.0 ]--
r 17     public PSKDTree(    ) { }
--[ 2022.11.11.13.42.56.392.0 ]--
r 17     public PSKDTree() { }
--[ 2022.11.11.13.29.50.882.0 ]--
:/src/PSBruteForce.java
+ 7 
+ 8 // Testing Git -- kmikels
+ 9 
--[ 2022.11.11.13.29.50.959.0 ]--
UpdateTree (AD): 72 0
+ /.git/info/exclude
+ /.git/logs/refs/heads/main
+ /.git/logs/refs/remotes/origin/main
+ /.git/logs/HEAD
+ /.git/refs/heads/main
+ /.git/refs/remotes/origin/main
+ /.git/hooks/update.sample
+ /.git/hooks/pre-push.sample
+ /.git/hooks/commit-msg.sample
+ /.git/hooks/pre-commit.sample
+ /.git/hooks/pre-rebase.sample
+ /.git/hooks/post-update.sample
+ /.git/hooks/pre-receive.sample
+ /.git/hooks/applypatch-msg.sample
+ /.git/hooks/pre-applypatch.sample
+ /.git/hooks/pre-merge-commit.sample
+ /.git/hooks/push-to-checkout.sample
+ /.git/hooks/fsmonitor-watchman.sample
+ /.git/hooks/prepare-commit-msg.sample
+ /.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
+ /.git/objects/05/054a55af449d7a3d22569a0d9278837d3116b7
+ /.git/objects/05/aa0754159021ad4bb196249ebed23fcaee0f05
+ /.git/objects/0d/90a95e4569ab236f012c54a903f79e23f7e45d
+ /.git/objects/0f/05624ad8de377d4bdf3ec1558d477af125661c
+ /.git/objects/11/6f5b50e2bd7e5a645224f577c702fc62092122
+ /.git/objects/1a/49d62b998226393c172907eef021434d19be9a
+ /.git/objects/1f/b9dc988a5179e983b847d789447e3c5fa79e57
+ /.git/objects/26/3963a64f2a64659282fd9cbe561dd7a5e4a676
+ /.git/objects/2b/5f9208bfadbbc9019b47a713b74462b9cd2613
+ /.git/objects/30/6f36bddc52f2e08ccf8a41536340870eb1829c
+ /.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
+ /.git/objects/39/5d98ffb25a1aa9df31eb7f0e6c2af2e28bc31d
+ /.git/objects/3c/91061820fd12503e015c3c19cec90b78494358
+ /.git/objects/43/34e267d8776aabbeb38713c0a502fa328ceb68
+ /.git/objects/49/554703073ae63a7122c05b80a894ac3ff48370
+ /.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
+ /.git/objects/5c/98b428844d9f7d529e2b6fb918d15bf072f3df
+ /.git/objects/65/427e6010f1b59257bc8ac509401e7eeb2698d4
+ /.git/objects/68/2820a134168b0d23787b376165bef89b511f00
+ /.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
+ /.git/objects/7d/61ee6e1564fdc3e562582a8ca1c55185fd2b09
+ /.git/objects/80/8df08d052527e9a626a08c732fb0fb470708c8
+ /.git/objects/8b/e37e197c873cbcd2952f364d9e3a447bc4e692
+ /.git/objects/8c/333a97e7dbd1f8d32d947ad097e8e247f9f041
+ /.git/objects/91/4c3a82a059ff11e1e2248c3ee1ce32a78bc63a
+ /.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
+ /.git/objects/9c/780ff1eacdac600ca19795de4e5f1220a1bf3e
+ /.git/objects/aa/90a9d65e85ba8dedaeee57dbca845093794f15
+ /.git/objects/aa/d3f0402094e10cd99e06ba2a544a57396b1919
+ /.git/objects/ae/39a65a74d4111e721807c06e27bd6754992fbb
+ /.git/objects/b4/a758f2f8c8a18b851825e056e555c5620ae676
+ /.git/objects/b6/90d19ac158bfa6e1ae11cef101f0d1a7434bd9
+ /.git/objects/c2/828bc31a68ae45ce1922d19323206b232cbda4
+ /.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
+ /.git/objects/ca/22da9b6c126b0744cfde03b32ebdff29cb41ab
+ /.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
+ /.git/objects/d2/e73db08c8563911c081a8651a77f67c4b48b43
+ /.git/objects/de/c87ed246fc3ca006dddb4db1972a0e1d67919e
+ /.git/objects/e2/3a8b692a016f63a83e1997a2326d3be18d8d1e
+ /.git/objects/e5/f5f06b6f0fb91e529051f1cb6651cc60ce2f48
+ /.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
+ /.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
+ /.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
+ /.git/objects/ef/89a8450022222b69a62814d66e3f6c8ecb5a60
+ /.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
+ /.git/objects/f6/cca8a6084310f182dc287fadbb82c5ebcfffe8
+ /.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
+ /.git/HEAD
+ /.git/index
+ /.git/config
+ /.git/description
+ /.git/COMMIT_EDITMSG

--[ 2022.11.11.13.29.57.388.0 ]--
UpdateTree (AD): 1 0
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_11_22,_1_29_PM_[Default]/shelved.patch

--[ 2022.11.11.13.29.57.425.0 ]--
UpdateTree (AD): 1 0
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_11_22__1_29_PM__Default_.xml

--[ 2022.11.11.13.30.43.260.0 ]--
UpdateTree (AD): 2 0
+ /.git/ORIG_HEAD
+ /.git/FETCH_HEAD

--[ 2022.11.11.13.40.15.511.0 ]--
:/src/PSKDTree.java
+ 17     public PSKDTree() { 
r 18     }
--[ 2022.11.11.13.40.16.006.0 ]--
+ 18         
--[ 2022.11.11.13.40.25.154.0 ]--
r 15     
--[ 2022.11.11.13.40.25.526.0 ]--
+ 15     
--[ 2022.11.11.13.40.25.818.0 ]--
r 16         
--[ 2022.11.11.13.40.26.525.0 ]--
r 16     
--[ 2022.11.11.13.41.19.526.0 ]--
r 15 
r 16 
r 18     public PSKDTree() {
--[ 2022.11.11.13.42.29.694.0 ]--
r 19         BST<String, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.56.385.0 ]--
r 19         BST<Pa, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.56.971.0 ]--
r 19         BST<P, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.57.517.0 ]--
r 19         BST<Po, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.57.672.0 ]--
r 19         BST<Poi, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.57.725.0 ]--
r 19         BST<Poin, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.57.933.0 ]--
r 19         BST<Point, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.59.625.0 ]--
r 19         BST<Point, V> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.59.751.0 ]--
r 19         BST<Point, Va> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.59.791.0 ]--
r 19         BST<Point, Val> st = new BST<String, Integer>();
--[ 2022.11.11.13.43.00.043.0 ]--
r 19         BST<Point, Valu> st = new BST<String, Integer>();
--[ 2022.11.11.13.43.00.079.0 ]--
r 19         BST<Point, Value> st = new BST<String, Integer>();
--[ 2022.11.11.13.43.01.661.0 ]--
r 19         BST<Point, Value> st = new BST<P, Integer>();
--[ 2022.11.11.13.43.01.779.0 ]--
r 19         BST<Point, Value> st = new BST<Po, Integer>();
--[ 2022.11.11.13.43.01.887.0 ]--
r 19         BST<Point, Value> st = new BST<Poi, Integer>();
--[ 2022.11.11.13.43.02.039.0 ]--
r 19         BST<Point, Value> st = new BST<Poin, Integer>();
--[ 2022.11.11.13.43.02.312.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Integer>();
--[ 2022.11.11.13.43.03.932.0 ]--
r 19         BST<Point, Value> st = new BST<Point, V>();
--[ 2022.11.11.13.43.04.135.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Va>();
--[ 2022.11.11.13.43.04.328.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Val>();
--[ 2022.11.11.13.43.04.449.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Valu>();
--[ 2022.11.11.13.43.04.551.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Value>();
--[ 2022.11.11.13.43.07.204.0 ]--
r 19         
--[ 2022.11.11.13.43.08.931.0 ]--
r 15 BST<Point, Value> st = new BST<Point, Value>();
--[ 2022.11.11.13.43.09.019.0 ]--
r 15     BST<Point, Value> st = new BST<Point, Value>();
--[ 2022.11.11.13.43.11.360.0 ]--
r 15     BST<Point, Value> s = new BST<Point, Value>();
--[ 2022.11.11.13.43.11.777.0 ]--
r 15     BST<Point, Value>  = new BST<Point, Value>();
--[ 2022.11.11.13.43.32.364.0 ]--
r 15     BST<Point, Value> k = new BST<Point, Value>();
--[ 2022.11.11.13.43.32.551.0 ]--
r 15     BST<Point, Value> ki = new BST<Point, Value>();
--[ 2022.11.11.13.43.32.810.0 ]--
r 15     BST<Point, Value> kid = new BST<Point, Value>();
--[ 2022.11.11.13.43.33.138.0 ]--
r 15     BST<Point, Value> ki = new BST<Point, Value>();
--[ 2022.11.11.13.43.33.284.0 ]--
r 15     BST<Point, Value> k = new BST<Point, Value>();
--[ 2022.11.11.13.43.33.381.0 ]--
r 15     BST<Point, Value> kd = new BST<Point, Value>();
--[ 2022.11.11.13.43.33.621.0 ]--
r 15     BST<Point, Value> kdt = new BST<Point, Value>();
--[ 2022.11.11.13.43.48.111.0 ]--
r 15     BST<Point, Value> kdt; = new BST<Point, Value>();
--[ 2022.11.11.13.43.50.918.0 ]--
r 15     BST<Point, Value> kdt; 
--[ 2022.11.11.13.43.51.897.0 ]--
r 19         k
--[ 2022.11.11.13.43.52.190.0 ]--
r 19         kd
--[ 2022.11.11.13.43.52.959.0 ]--
r 19         kdt
--[ 2022.11.11.13.43.53.077.0 ]--
r 19         kdt=
--[ 2022.11.11.13.43.53.255.0 ]--
r 19         kdt== new BST<Point, Value>();
--[ 2022.11.11.13.43.59.665.0 ]--
r 19         kdt== new BST();
--[ 2022.11.11.13.44.12.650.0 ]--
r 19         kdt== new BST<Point, Value>();
--[ 2022.11.11.13.44.15.316.0 ]--
r 19         kdt= new BST<Point, Value>();
--[ 2022.11.11.13.44.19.219.0 ]--
r 19         kdt = new BST<Point, Value>();
--[ 2022.11.11.13.44.31.105.0 ]--
r 23     public void put(Point p, Value v) {''
--[ 2022.11.11.13.44.39.214.0 ]--
r 23     public void put(Point p, Value v) {'
--[ 2022.11.11.13.44.39.351.0 ]--
r 23     public void put(Point p, Value v) {
--[ 2022.11.11.13.45.33.022.0 ]--
r 15     BST<Point, Value> kdt;
--[ 2022.11.11.13.46.48.583.0 ]--
+ 24         
--[ 2022.11.11.13.46.50.719.0 ]--
r 24         k
--[ 2022.11.11.13.46.51.186.0 ]--
r 24         kd
--[ 2022.11.11.13.46.51.420.0 ]--
r 24         kdt
--[ 2022.11.11.13.46.51.572.0 ]--
r 24         kdt.
--[ 2022.11.11.13.46.52.148.0 ]--
r 24         kdt.p
--[ 2022.11.11.13.46.52.539.0 ]--
r 24         kdt.pu
--[ 2022.11.11.13.46.53.008.0 ]--
r 24         kdt.put
--[ 2022.11.11.13.46.56.733.0 ]--
r 24         kdt.put()
--[ 2022.11.11.13.46.58.718.0 ]--
r 24         kdt.put(p,)
--[ 2022.11.11.13.46.58.944.0 ]--
r 24         kdt.put(p,v)
--[ 2022.11.11.13.47.00.106.0 ]--
r 24         kdt.put(p,v);
--[ 2022.11.11.13.47.11.832.0 ]--
+ 71         
--[ 2022.11.11.13.47.25.921.0 ]--
r 71         P
--[ 2022.11.11.13.47.26.221.0 ]--
r 71         PS
--[ 2022.11.11.13.47.26.558.0 ]--
r 71         PSK
--[ 2022.11.11.13.47.26.883.0 ]--
r 71         PSKD
--[ 2022.11.11.13.47.27.568.0 ]--
r 71         PSKDT
--[ 2022.11.11.13.47.27.893.0 ]--
r 71         PSKDTr
--[ 2022.11.11.13.47.28.401.0 ]--
r 71         PSKDTre
--[ 2022.11.11.13.47.28.941.0 ]--
r 71         PSKDTree
--[ 2022.11.11.13.47.33.880.0 ]--
r 71         PSKDTree<>
--[ 2022.11.11.13.47.34.343.0 ]--
r 71         PSKDTree<i>
--[ 2022.11.11.13.47.34.526.0 ]--
r 71         PSKDTree<in>
--[ 2022.11.11.13.47.34.729.0 ]--
r 71         PSKDTree<int>
--[ 2022.11.11.13.47.36.112.0 ]--
r 71         PSKDTree<int
--[ 2022.11.11.13.47.36.452.0 ]--
r 71         PSKDTree<in
--[ 2022.11.11.13.47.36.587.0 ]--
r 71         PSKDTree<i
--[ 2022.11.11.13.47.36.683.0 ]--
r 71         PSKDTree<
--[ 2022.11.11.13.47.37.110.0 ]--
r 71         PSKDTree<I
--[ 2022.11.11.13.47.37.216.0 ]--
r 71         PSKDTree<In
--[ 2022.11.11.13.47.37.333.0 ]--
r 71         PSKDTree<Int
--[ 2022.11.11.13.47.37.628.0 ]--
r 71         PSKDTree<Inte
--[ 2022.11.11.13.47.37.977.0 ]--
r 71         PSKDTree<Integ
--[ 2022.11.11.13.47.38.136.0 ]--
r 71         PSKDTree<Intege
--[ 2022.11.11.13.47.38.235.0 ]--
r 71         PSKDTree<Integer
--[ 2022.11.11.13.47.38.786.0 ]--
r 71         PSKDTree<Integer>
--[ 2022.11.11.13.47.39.026.0 ]--
r 71         PSKDTree<Integer> 
--[ 2022.11.11.13.47.42.811.0 ]--
r 71         PSKDTree<Integer> =
--[ 2022.11.11.13.47.42.936.0 ]--
r 71         PSKDTree<Integer> = 
--[ 2022.11.11.13.47.43.519.0 ]--
r 71         PSKDTree<Integer> =
--[ 2022.11.11.13.47.43.649.0 ]--
r 71         PSKDTree<Integer> 
--[ 2022.11.11.13.47.43.814.0 ]--
r 71         PSKDTree<Integer>
--[ 2022.11.11.13.47.44.256.0 ]--
r 71         PSKDTree<Integer> 
--[ 2022.11.11.13.47.45.553.0 ]--
r 71         PSKDTree<Integer> t
--[ 2022.11.11.13.47.45.690.0 ]--
r 71         PSKDTree<Integer> te
--[ 2022.11.11.13.47.45.756.0 ]--
r 71         PSKDTree<Integer> tes
--[ 2022.11.11.13.47.45.888.0 ]--
r 71         PSKDTree<Integer> test
--[ 2022.11.11.13.47.46.052.0 ]--
r 71         PSKDTree<Integer> test 
--[ 2022.11.11.13.47.46.165.0 ]--
r 71         PSKDTree<Integer> test =
--[ 2022.11.11.13.47.46.279.0 ]--
r 71         PSKDTree<Integer> test = 
--[ 2022.11.11.13.47.49.153.0 ]--
r 71         PSKDTree<Integer> test = n
--[ 2022.11.11.13.47.49.286.0 ]--
r 71         PSKDTree<Integer> test = ne
--[ 2022.11.11.13.47.49.409.0 ]--
r 71         PSKDTree<Integer> test = new
--[ 2022.11.11.13.47.49.768.0 ]--
r 71         PSKDTree<Integer> test = new 
--[ 2022.11.11.13.47.50.759.0 ]--
r 71         PSKDTree<Integer> test = new P
--[ 2022.11.11.13.47.51.513.0 ]--
r 71         PSKDTree<Integer> test = new PS
--[ 2022.11.11.13.47.52.104.0 ]--
r 71         PSKDTree<Integer> test = new PSK
--[ 2022.11.11.13.47.52.667.0 ]--
r 71         PSKDTree<Integer> test = new PSKD
--[ 2022.11.11.13.47.52.990.0 ]--
r 71         PSKDTree<Integer> test = new PSKDT
--[ 2022.11.11.13.47.53.188.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTr
--[ 2022.11.11.13.47.53.377.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTre
--[ 2022.11.11.13.47.53.544.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree
--[ 2022.11.11.13.47.54.582.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree()
--[ 2022.11.11.13.47.55.849.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(I)
--[ 2022.11.11.13.47.56.019.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(In)
--[ 2022.11.11.13.47.56.499.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Int)
--[ 2022.11.11.13.47.57.091.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Inte)
--[ 2022.11.11.13.47.57.370.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Integ)
--[ 2022.11.11.13.47.57.689.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Intege)
--[ 2022.11.11.13.47.57.753.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Integer)
--[ 2022.11.11.13.48.05.897.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Integer
--[ 2022.11.11.13.48.06.007.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Intege
--[ 2022.11.11.13.48.06.156.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Integ
--[ 2022.11.11.13.48.06.304.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Inte
--[ 2022.11.11.13.48.06.465.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Int
--[ 2022.11.11.13.48.06.618.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(In
--[ 2022.11.11.13.48.06.781.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(I
--[ 2022.11.11.13.48.06.925.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(
--[ 2022.11.11.13.48.07.076.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree
--[ 2022.11.11.13.48.07.745.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<>
--[ 2022.11.11.13.48.08.254.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<I>
--[ 2022.11.11.13.48.08.390.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<In>
--[ 2022.11.11.13.48.08.709.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Int>
--[ 2022.11.11.13.48.09.053.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Inte>
--[ 2022.11.11.13.48.09.224.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integ>
--[ 2022.11.11.13.48.09.368.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Intege>
--[ 2022.11.11.13.48.09.477.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integer>
--[ 2022.11.11.13.48.10.289.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integer>()
--[ 2022.11.11.13.48.10.653.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integer>();
--[ 2022.11.11.13.48.11.104.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integer>(); 
--[ 2022.11.11.13.48.15.385.0 ]--
+ 72         
--[ 2022.11.11.13.48.16.435.0 ]--
r 72         t
--[ 2022.11.11.13.48.16.549.0 ]--
r 72         te
--[ 2022.11.11.13.48.16.729.0 ]--
r 72         tes
--[ 2022.11.11.13.48.17.015.0 ]--
r 72         test
--[ 2022.11.11.13.48.17.234.0 ]--
r 72         test.
--[ 2022.11.11.13.48.17.564.0 ]--
r 72         test.p
--[ 2022.11.11.13.48.17.898.0 ]--
r 72         test.pu
--[ 2022.11.11.13.48.18.269.0 ]--
r 72         test.put
--[ 2022.11.11.13.48.34.135.0 ]--
r 72         test.put()
--[ 2022.11.11.13.48.45.783.0 ]--
+ 71         
--[ 2022.11.11.13.48.46.664.0 ]--
r 71         P
--[ 2022.11.11.13.48.47.204.0 ]--
r 71         Po
--[ 2022.11.11.13.48.47.463.0 ]--
r 71         Poi
--[ 2022.11.11.13.48.48.142.0 ]--
r 71         Poin
--[ 2022.11.11.13.48.48.700.0 ]--
r 71         Point
--[ 2022.11.11.13.48.49.081.0 ]--
r 71         Point 
--[ 2022.11.11.13.48.49.552.0 ]--
r 71         Point  
--[ 2022.11.11.13.48.50.163.0 ]--
r 71         Point  t
--[ 2022.11.11.13.48.50.514.0 ]--
r 71         Point  
--[ 2022.11.11.13.48.50.654.0 ]--
r 71         Point 
--[ 2022.11.11.13.48.50.767.0 ]--
r 71         Point
--[ 2022.11.11.13.48.51.277.0 ]--
r 71         Point 
--[ 2022.11.11.13.48.51.602.0 ]--
r 71         Point x
--[ 2022.11.11.13.48.51.995.0 ]--
r 71         Point x 
--[ 2022.11.11.13.48.52.445.0 ]--
r 71         Point x =
--[ 2022.11.11.13.48.52.827.0 ]--
r 71         Point x = 
--[ 2022.11.11.13.49.00.733.0 ]--
r 71         Point x = ne
--[ 2022.11.11.13.49.00.873.0 ]--
r 71         Point x = new
--[ 2022.11.11.13.49.01.015.0 ]--
r 71         Point x = new 
--[ 2022.11.11.13.49.01.267.0 ]--
r 71         Point x = new P
--[ 2022.11.11.13.49.01.687.0 ]--
r 71         Point x = new Po
--[ 2022.11.11.13.49.01.788.0 ]--
r 71         Point x = new Poi
--[ 2022.11.11.13.49.01.852.0 ]--
r 71         Point x = new Poin
--[ 2022.11.11.13.49.01.948.0 ]--
r 71         Point x = new Point
--[ 2022.11.11.13.49.02.430.0 ]--
r 71         Point x = new Point()
--[ 2022.11.11.13.49.03.654.0 ]--
r 71         Point x = new Point(1)
--[ 2022.11.11.13.49.03.733.0 ]--
r 71         Point x = new Point(1.)
--[ 2022.11.11.13.49.03.892.0 ]--
r 71         Point x = new Point(1.0)
--[ 2022.11.11.13.49.04.091.0 ]--
r 71         Point x = new Point(1.0,)
--[ 2022.11.11.13.49.04.686.0 ]--
r 71         Point x = new Point(1.0,2.0)
--[ 2022.11.11.13.49.06.068.0 ]--
r 71         Point x = new Point(1.0,2.0);
--[ 2022.11.11.13.49.10.406.0 ]--
r 73         test.put(x)
--[ 2022.11.11.13.49.10.672.0 ]--
r 73         test.put(x,)
--[ 2022.11.11.13.49.11.240.0 ]--
r 73         test.put(x, )
--[ 2022.11.11.13.49.12.242.0 ]--
r 73         test.put(x, 3)
--[ 2022.11.11.13.49.13.407.0 ]--
r 73         test.put(x, 3);
--[ 2022.11.11.13.49.50.158.0 ]--
+ 74         
--[ 2022.11.11.13.49.50.414.0 ]--
r 74         f
--[ 2022.11.11.13.49.50.658.0 ]--
r 74         fo
--[ 2022.11.11.13.49.50.942.0 ]--
r 74         for
--[ 2022.11.11.13.49.51.214.0 ]--
r 74         for 
--[ 2022.11.11.13.49.52.235.0 ]--
r 74         for ()
--[ 2022.11.11.13.49.55.379.0 ]--
r 74         for (S)
--[ 2022.11.11.13.49.56.322.0 ]--
r 74         for (ST)
--[ 2022.11.11.13.49.56.614.0 ]--
r 74         for (STr)
--[ 2022.11.11.13.49.57.065.0 ]--
r 74         for (ST)
--[ 2022.11.11.13.49.57.141.0 ]--
r 74         for (S)
--[ 2022.11.11.13.49.57.266.0 ]--
r 74         for (St)
--[ 2022.11.11.13.49.57.531.0 ]--
r 74         for (Str)
--[ 2022.11.11.13.49.58.313.0 ]--
r 74         for (String)
--[ 2022.11.11.13.49.58.618.0 ]--
r 74         for (String )
--[ 2022.11.11.13.49.59.610.0 ]--
r 74         for (String)
--[ 2022.11.11.13.49.59.663.0 ]--
r 74         for (Strin)
--[ 2022.11.11.13.49.59.791.0 ]--
r 74         for (Stri)
--[ 2022.11.11.13.49.59.939.0 ]--
r 74         for (Str)
--[ 2022.11.11.13.50.00.086.0 ]--
r 74         for (St)
--[ 2022.11.11.13.50.00.221.0 ]--
r 74         for (S)
--[ 2022.11.11.13.50.00.365.0 ]--
r 74         for ()
--[ 2022.11.11.13.50.09.894.0 ]--
r 74         for (P)
--[ 2022.11.11.13.50.10.206.0 ]--
r 74         for (Po)
--[ 2022.11.11.13.50.10.269.0 ]--
r 74         for (Poi)
--[ 2022.11.11.13.50.10.367.0 ]--
r 74         for (Poin)
--[ 2022.11.11.13.50.10.572.0 ]--
r 74         for (Point)
--[ 2022.11.11.13.50.11.554.0 ]--
r 74         for (Point )
--[ 2022.11.11.13.50.12.059.0 ]--
r 74         for (Point s)
--[ 2022.11.11.13.50.12.401.0 ]--
r 74         for (Point s:)
--[ 2022.11.11.13.50.13.502.0 ]--
r 74         for (Point s:s)
--[ 2022.11.11.13.50.13.802.0 ]--
r 74         for (Point s:st)
--[ 2022.11.11.13.50.14.623.0 ]--
r 74         for (Point s:s)
--[ 2022.11.11.13.50.14.736.0 ]--
r 74         for (Point s:)
--[ 2022.11.11.13.50.17.814.0 ]--
r 74         for (Point s:t)
--[ 2022.11.11.13.50.18.282.0 ]--
r 74         for (Point s:te)
--[ 2022.11.11.13.50.18.397.0 ]--
r 74         for (Point s:tes)
--[ 2022.11.11.13.50.18.587.0 ]--
r 74         for (Point s:test)
--[ 2022.11.11.13.50.19.707.0 ]--
r 74         for (Point s:test.)
--[ 2022.11.11.13.50.20.029.0 ]--
r 74         for (Point s:test.k)
--[ 2022.11.11.13.50.20.196.0 ]--
r 74         for (Point s:test.ke)
--[ 2022.11.11.13.50.20.360.0 ]--
r 74         for (Point s:test.key)
--[ 2022.11.11.13.50.20.853.0 ]--
r 74         for (Point s:test.keys)
--[ 2022.11.11.13.50.21.434.0 ]--
r 74         for (Point s:test.keys())
--[ 2022.11.11.13.50.30.971.0 ]--
r 74         
--[ 2022.11.11.13.50.34.300.0 ]--
- 71
- 71
r 71         
--[ 2022.11.11.13.50.34.836.0 ]--
- 71
--[ 2022.11.11.13.50.35.541.0 ]--
r 70     public static void main(String[] args) 
--[ 2022.11.11.13.50.36.571.0 ]--
r 70     public static void main(String[] args) {
--[ 2022.11.11.13.50.38.288.0 ]--
- 71
--[ 2022.11.11.13.51.18.405.0 ]--
r 23     public void put(Point p, Value v) { 
--[ 2022.11.11.13.51.18.465.0 ]--
r 23     public void put(Point p, Value v) {  
--[ 2022.11.11.13.51.19.128.0 ]--
r 23     public void put(Point p, Value v) {  /
--[ 2022.11.11.13.51.19.240.0 ]--
r 23     public void put(Point p, Value v) {  //
--[ 2022.11.11.13.51.19.740.0 ]--
r 23     public void put(Point p, Value v) {  //c
--[ 2022.11.11.13.51.19.908.0 ]--
r 23     public void put(Point p, Value v) {  //ca
--[ 2022.11.11.13.51.20.059.0 ]--
r 23     public void put(Point p, Value v) {  //cah
--[ 2022.11.11.13.51.20.264.0 ]--
r 23     public void put(Point p, Value v) {  //cahn
--[ 2022.11.11.13.51.20.368.0 ]--
r 23     public void put(Point p, Value v) {  //cahng
--[ 2022.11.11.13.51.20.574.0 ]--
r 23     public void put(Point p, Value v) {  //cahnge
--[ 2022.11.11.13.51.21.732.0 ]--
r 23     public void put(Point p, Value v) {  //cahng
--[ 2022.11.11.13.51.21.839.0 ]--
r 23     public void put(Point p, Value v) {  //cahn
--[ 2022.11.11.13.51.22.013.0 ]--
r 23     public void put(Point p, Value v) {  //cah
--[ 2022.11.11.13.51.22.158.0 ]--
r 23     public void put(Point p, Value v) {  //ca
--[ 2022.11.11.13.51.22.291.0 ]--
r 23     public void put(Point p, Value v) {  //c
--[ 2022.11.11.13.51.22.683.0 ]--
r 23     public void put(Point p, Value v) {  //ch
--[ 2022.11.11.13.51.22.789.0 ]--
r 23     public void put(Point p, Value v) {  //cha
--[ 2022.11.11.13.51.22.873.0 ]--
r 23     public void put(Point p, Value v) {  //chan
--[ 2022.11.11.13.51.23.126.0 ]--
r 23     public void put(Point p, Value v) {  //chang
--[ 2022.11.11.13.51.23.843.0 ]--
r 23     public void put(Point p, Value v) {  //change
--[ 2022.11.11.13.51.24.402.0 ]--
r 23     public void put(Point p, Value v) {  //change?
--[ 2022.11.11.13.51.24.531.0 ]--
r 23     public void put(Point p, Value v) {  //change??
--[ 2022.11.11.13.54.01.140.0 ]--
+ 16     
--[ 2022.11.11.13.54.02.807.0 ]--
r 16     i
--[ 2022.11.11.13.54.02.870.0 ]--
r 16     in
--[ 2022.11.11.13.54.03.141.0 ]--
r 16     int
--[ 2022.11.11.13.54.03.175.0 ]--
r 16     int 
--[ 2022.11.11.13.54.03.412.0 ]--
r 16     int s
--[ 2022.11.11.13.54.03.507.0 ]--
r 16     int si
--[ 2022.11.11.13.54.03.759.0 ]--
r 16     int siz
--[ 2022.11.11.13.54.04.043.0 ]--
r 16     int size
--[ 2022.11.11.13.54.04.600.0 ]--
r 16     int size;
--[ 2022.11.11.13.54.06.885.0 ]--
r 16     int c;
--[ 2022.11.11.13.54.06.997.0 ]--
r 16     int cp;
--[ 2022.11.11.13.54.07.045.0 ]--
r 16     int cpo;
--[ 2022.11.11.13.54.07.392.0 ]--
r 16     int cp;
--[ 2022.11.11.13.54.07.503.0 ]--
r 16     int c;
--[ 2022.11.11.13.54.08.109.0 ]--
r 16     int co;
--[ 2022.11.11.13.54.08.196.0 ]--
r 16     int cou;
--[ 2022.11.11.13.54.08.387.0 ]--
r 16     int coun;
--[ 2022.11.11.13.54.08.516.0 ]--
r 16     int count;
--[ 2022.11.11.13.54.14.019.0 ]--
r 16     int count=;
--[ 2022.11.11.13.54.14.177.0 ]--
r 16     int count=0;
--[ 2022.11.11.13.54.17.530.0 ]--
+ 26         
--[ 2022.11.11.13.54.17.886.0 ]--
r 26         c
--[ 2022.11.11.13.54.17.979.0 ]--
r 26         co
--[ 2022.11.11.13.54.18.147.0 ]--
r 26         cou
--[ 2022.11.11.13.54.18.250.0 ]--
r 26         cout
--[ 2022.11.11.13.54.18.566.0 ]--
r 26         cout+
--[ 2022.11.11.13.54.18.690.0 ]--
r 26         cout++
--[ 2022.11.11.13.54.18.879.0 ]--
r 26         cout++;
--[ 2022.11.11.13.54.21.288.0 ]--
r 26         count++;
--[ 2022.11.11.13.54.30.943.0 ]--
r 69     public boolean isEmpty() { return tc; }
--[ 2022.11.11.13.54.31.214.0 ]--
r 69     public boolean isEmpty() { return t; }
--[ 2022.11.11.13.54.31.339.0 ]--
r 69     public boolean isEmpty() { return ; }
--[ 2022.11.11.13.54.31.684.0 ]--
r 69     public boolean isEmpty() { return c; }
--[ 2022.11.11.13.54.31.964.0 ]--
r 69     public boolean isEmpty() { return co; }
--[ 2022.11.11.13.54.32.140.0 ]--
r 69     public boolean isEmpty() { return cou; }
--[ 2022.11.11.13.54.32.407.0 ]--
r 69     public boolean isEmpty() { return coun; }
--[ 2022.11.11.13.54.32.527.0 ]--
r 69     public boolean isEmpty() { return count; }
--[ 2022.11.11.13.54.32.809.0 ]--
r 69     public boolean isEmpty() { return count=; }
--[ 2022.11.11.13.54.33.172.0 ]--
r 69     public boolean isEmpty() { return count==; }
--[ 2022.11.11.13.54.33.441.0 ]--
r 69     public boolean isEmpty() { return count==0; }
--[ 2022.11.11.13.54.35.263.0 ]--
r 66     public int size() { return ; }
--[ 2022.11.11.13.54.35.523.0 ]--
r 66     public int size() { return c; }
--[ 2022.11.11.13.54.35.732.0 ]--
r 66     public int size() { return co; }
--[ 2022.11.11.13.54.35.783.0 ]--
r 66     public int size() { return cou; }
--[ 2022.11.11.13.54.36.007.0 ]--
r 66     public int size() { return coun; }
--[ 2022.11.11.13.54.36.163.0 ]--
r 66     public int size() { return count; }
--[ 2022.11.11.13.55.15.679.0 ]--
r 17     
--[ 2022.11.11.13.55.49.049.0 ]--
r 17     e
--[ 2022.11.11.13.55.51.175.0 ]--
r 17     
--[ 2022.11.11.13.55.58.305.0 ]--
r 17     P
--[ 2022.11.11.13.55.58.501.0 ]--
r 17     Po
--[ 2022.11.11.13.55.58.602.0 ]--
r 17     Poi
--[ 2022.11.11.13.55.58.716.0 ]--
r 17     Poin
--[ 2022.11.11.13.55.58.884.0 ]--
r 17     Point
--[ 2022.11.11.13.55.58.990.0 ]--
r 17     Point 
--[ 2022.11.11.13.55.59.084.0 ]--
r 17     Point m
--[ 2022.11.11.13.55.59.223.0 ]--
r 17     Point mi
--[ 2022.11.11.13.55.59.433.0 ]--
r 17     Point min
--[ 2022.11.11.13.55.59.806.0 ]--
r 17     Point mini
--[ 2022.11.11.13.56.00.554.0 ]--
r 17     Point minim
--[ 2022.11.11.13.56.00.722.0 ]--
r 17     Point minimu
--[ 2022.11.11.13.56.00.898.0 ]--
r 17     Point minimun
--[ 2022.11.11.13.56.01.588.0 ]--
r 17     Point minimu
--[ 2022.11.11.13.56.01.903.0 ]--
r 17     Point minimum
--[ 2022.11.11.13.56.02.160.0 ]--
r 17     Point minimum;
--[ 2022.11.11.13.56.02.462.0 ]--
+ 18     
--[ 2022.11.11.13.56.03.745.0 ]--
r 18     Poi
--[ 2022.11.11.13.56.03.960.0 ]--
r 18     Poin
--[ 2022.11.11.13.56.04.416.0 ]--
r 18     Point
--[ 2022.11.11.13.56.07.165.0 ]--
r 18     Point 
--[ 2022.11.11.13.56.07.286.0 ]--
r 18     Point m
--[ 2022.11.11.13.56.07.525.0 ]--
r 18     Point ma
--[ 2022.11.11.13.56.08.320.0 ]--
r 18     Point max
--[ 2022.11.11.13.56.08.539.0 ]--
r 18     Point maxi
--[ 2022.11.11.13.56.08.828.0 ]--
r 18     Point maxim
--[ 2022.11.11.13.56.09.067.0 ]--
r 18     Point maximu
--[ 2022.11.11.13.56.09.274.0 ]--
r 18     Point maximum
--[ 2022.11.11.13.56.09.630.0 ]--
r 18     Point maximum;
--[ 2022.11.11.21.34.27.936.0 ]--
+ 63     public Point min() { 
r 64         return null; }
--[ 2022.11.11.21.34.29.308.0 ]--
+ 64         return null; 
r 65     }
--[ 2022.11.11.21.34.30.933.0 ]--
+ 64         
--[ 2022.11.11.21.34.31.376.0 ]--
r 64         i
--[ 2022.11.11.21.34.31.487.0 ]--
r 64         if
--[ 2022.11.11.21.34.32.190.0 ]--
r 64         if()
--[ 2022.11.11.21.34.32.350.0 ]--
r 64         if(i)
--[ 2022.11.11.21.34.32.488.0 ]--
r 64         if(is)
--[ 2022.11.11.21.34.32.855.0 ]--
r 64         if(isE)
--[ 2022.11.11.21.34.32.964.0 ]--
r 64         if(isEm)
--[ 2022.11.11.21.34.34.069.0 ]--
r 64         if(isEmp)
--[ 2022.11.11.21.34.34.349.0 ]--
r 64         if(isEmpt)
--[ 2022.11.11.21.34.34.924.0 ]--
r 64         if(isEmpty)
--[ 2022.11.11.21.34.35.480.0 ]--
r 64         if(isEmpty())
--[ 2022.11.11.21.34.38.678.0 ]--
r 64         if(isEmpty()) 
--[ 2022.11.11.21.34.38.832.0 ]--
r 64         if(isEmpty()) r
--[ 2022.11.11.21.34.39.106.0 ]--
r 64         if(isEmpty()) re
--[ 2022.11.11.21.34.39.276.0 ]--
r 64         if(isEmpty()) ret
--[ 2022.11.11.21.34.39.386.0 ]--
r 64         if(isEmpty()) retu
--[ 2022.11.11.21.34.39.512.0 ]--
r 64         if(isEmpty()) retur
--[ 2022.11.11.21.34.39.973.0 ]--
r 64         if(isEmpty()) return
--[ 2022.11.11.21.34.40.145.0 ]--
r 64         if(isEmpty()) return 
--[ 2022.11.11.21.34.40.328.0 ]--
r 64         if(isEmpty()) return n
--[ 2022.11.11.21.34.40.516.0 ]--
r 64         if(isEmpty()) return nu
--[ 2022.11.11.21.34.40.747.0 ]--
r 64         if(isEmpty()) return nul
--[ 2022.11.11.21.34.40.874.0 ]--
r 64         if(isEmpty()) return null
--[ 2022.11.11.21.34.41.339.0 ]--
r 64         if(isEmpty()) return null;
--[ 2022.11.11.21.34.45.856.0 ]--
r 65        
--[ 2022.11.11.21.34.46.234.0 ]--
- 65
--[ 2022.11.11.21.34.53.260.0 ]--
r 66     public Point max() { if(isEmpty()) return null; }
--[ 2022.11.11.21.34.54.359.0 ]--
+ 66     public Point max() { if(isEmpty()) return null;
r 67     }
--[ 2022.11.11.21.34.55.758.0 ]--
+ 66     public Point max() { 
r 67         if(isEmpty()) return null;
--[ 2022.11.11.21.34.58.794.0 ]--
+ 68         
--[ 2022.11.11.21.35.00.513.0 ]--
r 68         r
--[ 2022.11.11.21.35.00.626.0 ]--
r 68         re
--[ 2022.11.11.21.35.00.779.0 ]--
r 68         ret
--[ 2022.11.11.21.35.01.811.0 ]--
r 68         retu
--[ 2022.11.11.21.35.02.177.0 ]--
r 68         retur
--[ 2022.11.11.21.35.02.273.0 ]--
r 68         return
--[ 2022.11.11.21.35.02.416.0 ]--
r 68         return 
--[ 2022.11.11.21.35.02.975.0 ]--
r 68         return n
--[ 2022.11.11.21.35.03.183.0 ]--
r 68         return nu
--[ 2022.11.11.21.35.03.389.0 ]--
r 68         return nul
--[ 2022.11.11.21.35.04.092.0 ]--
r 68         return null
--[ 2022.11.11.21.35.04.246.0 ]--
r 68         return null;
--[ 2022.11.11.21.35.05.563.0 ]--
+ 65         
--[ 2022.11.11.21.35.05.831.0 ]--
r 65         r
--[ 2022.11.11.21.35.05.989.0 ]--
r 65         re
--[ 2022.11.11.21.35.06.169.0 ]--
r 65         ret
--[ 2022.11.11.21.35.06.524.0 ]--
r 65         retu
--[ 2022.11.11.21.35.06.738.0 ]--
r 65         retur
--[ 2022.11.11.21.35.06.908.0 ]--
r 65         return
--[ 2022.11.11.21.35.07.332.0 ]--
r 65         return 
--[ 2022.11.11.21.35.07.653.0 ]--
r 65         return n
--[ 2022.11.11.21.35.07.881.0 ]--
r 65         return nu
--[ 2022.11.11.21.35.08.124.0 ]--
r 65         return nul
--[ 2022.11.11.21.35.08.231.0 ]--
r 65         return null
--[ 2022.11.11.21.35.08.611.0 ]--
r 65         return null;
--[ 2022.11.11.21.35.17.289.0 ]--
r 63     public Point min() {
r 67     public Point max() {
--[ 2022.11.11.21.35.33.183.0 ]--
+ 31         
--[ 2022.11.11.21.35.33.464.0 ]--
r 31         i
--[ 2022.11.11.21.35.33.610.0 ]--
r 31         if
--[ 2022.11.11.21.35.43.782.0 ]--
r 31         if()
--[ 2022.11.11.21.35.43.991.0 ]--
r 31         if(i)
--[ 2022.11.11.21.35.44.225.0 ]--
r 31         if(is)
--[ 2022.11.11.21.35.44.547.0 ]--
r 31         if(isE)
--[ 2022.11.11.21.35.44.673.0 ]--
r 31         if(isEm)
--[ 2022.11.11.21.35.44.903.0 ]--
r 31         if(isEmp)
--[ 2022.11.11.21.35.45.146.0 ]--
r 31         if(isEmpt)
--[ 2022.11.11.21.35.45.378.0 ]--
r 31         if(isEmpty)
--[ 2022.11.11.21.35.46.039.0 ]--
r 31         if(isEmpty())
--[ 2022.11.11.21.36.04.198.0 ]--
r 31         if(isEmpty()) 
--[ 2022.11.11.21.36.04.388.0 ]--
r 31         if(isEmpty()) r
--[ 2022.11.11.21.36.04.531.0 ]--
r 31         if(isEmpty()) re
--[ 2022.11.11.21.36.04.697.0 ]--
r 31         if(isEmpty()) ret
--[ 2022.11.11.21.36.04.820.0 ]--
r 31         if(isEmpty()) retu
--[ 2022.11.11.21.36.05.028.0 ]--
r 31         if(isEmpty()) retur
--[ 2022.11.11.21.36.05.226.0 ]--
r 31         if(isEmpty()) return
--[ 2022.11.11.21.36.05.398.0 ]--
r 31         if(isEmpty()) return 
--[ 2022.11.11.21.36.05.547.0 ]--
r 31         if(isEmpty()) return n
--[ 2022.11.11.21.36.05.739.0 ]--
r 31         if(isEmpty()) return nu
--[ 2022.11.11.21.36.05.967.0 ]--
r 31         if(isEmpty()) return nuo
--[ 2022.11.11.21.36.06.092.0 ]--
r 31         if(isEmpty()) return nuoo
--[ 2022.11.11.21.36.06.620.0 ]--
r 31         if(isEmpty()) return nuo
--[ 2022.11.11.21.36.07.600.0 ]--
r 31         if(isEmpty()) return nu
--[ 2022.11.11.21.36.08.252.0 ]--
r 31         if(isEmpty()) return nu;
--[ 2022.11.11.21.36.08.428.0 ]--
r 31         if(isEmpty()) return nu;;
--[ 2022.11.11.21.36.09.037.0 ]--
r 31         if(isEmpty()) return nu;
--[ 2022.11.11.21.36.09.186.0 ]--
r 31         if(isEmpty()) return nu
--[ 2022.11.11.21.36.09.724.0 ]--
r 31         if(isEmpty()) return nul
--[ 2022.11.11.21.36.10.391.0 ]--
r 31         if(isEmpty()) return null;
--[ 2022.11.11.21.37.30.547.0 ]--
+ 40         
--[ 2022.11.11.21.37.32.551.0 ]--
r 40         if(isEmpty()) return null;
--[ 2022.11.11.21.40.32.832.0 ]--
DisposeComponent
--[ 2022.11.15.11.28.21.068.0 ]--
NewLogger: P05_KDTrees
Version: 1.5
--[ 2022.11.15.11.28.21.410.0 ]--
InitTree:
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.git/info/exclude
/.git/logs/refs/heads/main
/.git/logs/refs/remotes/origin/main
/.git/logs/HEAD
/.git/refs/heads/main
/.git/refs/remotes/origin/main
/.git/hooks/update.sample
/.git/hooks/pre-push.sample
/.git/hooks/commit-msg.sample
/.git/hooks/pre-commit.sample
/.git/hooks/pre-rebase.sample
/.git/hooks/post-update.sample
/.git/hooks/pre-receive.sample
/.git/hooks/applypatch-msg.sample
/.git/hooks/pre-applypatch.sample
/.git/hooks/pre-merge-commit.sample
/.git/hooks/push-to-checkout.sample
/.git/hooks/fsmonitor-watchman.sample
/.git/hooks/prepare-commit-msg.sample
/.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
/.git/objects/05/054a55af449d7a3d22569a0d9278837d3116b7
/.git/objects/05/aa0754159021ad4bb196249ebed23fcaee0f05
/.git/objects/0d/90a95e4569ab236f012c54a903f79e23f7e45d
/.git/objects/0f/05624ad8de377d4bdf3ec1558d477af125661c
/.git/objects/11/6f5b50e2bd7e5a645224f577c702fc62092122
/.git/objects/1a/49d62b998226393c172907eef021434d19be9a
/.git/objects/1f/b9dc988a5179e983b847d789447e3c5fa79e57
/.git/objects/26/3963a64f2a64659282fd9cbe561dd7a5e4a676
/.git/objects/2b/5f9208bfadbbc9019b47a713b74462b9cd2613
/.git/objects/30/6f36bddc52f2e08ccf8a41536340870eb1829c
/.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
/.git/objects/39/5d98ffb25a1aa9df31eb7f0e6c2af2e28bc31d
/.git/objects/3c/91061820fd12503e015c3c19cec90b78494358
/.git/objects/43/34e267d8776aabbeb38713c0a502fa328ceb68
/.git/objects/49/554703073ae63a7122c05b80a894ac3ff48370
/.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
/.git/objects/54/0fd2392eaf74abc751e9970668bf235e56f803
/.git/objects/5c/98b428844d9f7d529e2b6fb918d15bf072f3df
/.git/objects/65/427e6010f1b59257bc8ac509401e7eeb2698d4
/.git/objects/68/2820a134168b0d23787b376165bef89b511f00
/.git/objects/6e/e6bdaf464e0f4adb373587a385e0875ebf8ba6
/.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
/.git/objects/7d/61ee6e1564fdc3e562582a8ca1c55185fd2b09
/.git/objects/80/8df08d052527e9a626a08c732fb0fb470708c8
/.git/objects/86/5b56d35df1dcfcbf5196eeddcef674c03a3a93
/.git/objects/8b/e37e197c873cbcd2952f364d9e3a447bc4e692
/.git/objects/8c/333a97e7dbd1f8d32d947ad097e8e247f9f041
/.git/objects/8d/e804238c33c653fe535bd162aabed440497ec7
/.git/objects/91/4c3a82a059ff11e1e2248c3ee1ce32a78bc63a
/.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
/.git/objects/9a/8c6aff1f8871e01cacec32f40b40f4107494d2
/.git/objects/9c/780ff1eacdac600ca19795de4e5f1220a1bf3e
/.git/objects/aa/90a9d65e85ba8dedaeee57dbca845093794f15
/.git/objects/aa/d3f0402094e10cd99e06ba2a544a57396b1919
/.git/objects/ae/39a65a74d4111e721807c06e27bd6754992fbb
/.git/objects/b4/a758f2f8c8a18b851825e056e555c5620ae676
/.git/objects/b6/90d19ac158bfa6e1ae11cef101f0d1a7434bd9
/.git/objects/c2/828bc31a68ae45ce1922d19323206b232cbda4
/.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
/.git/objects/c7/ed19fcb2ed6617a23bd3e9a2efaa966bed42da
/.git/objects/ca/22da9b6c126b0744cfde03b32ebdff29cb41ab
/.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
/.git/objects/d2/e73db08c8563911c081a8651a77f67c4b48b43
/.git/objects/de/c87ed246fc3ca006dddb4db1972a0e1d67919e
/.git/objects/e2/3a8b692a016f63a83e1997a2326d3be18d8d1e
/.git/objects/e5/f5f06b6f0fb91e529051f1cb6651cc60ce2f48
/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
/.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
/.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
/.git/objects/ef/89a8450022222b69a62814d66e3f6c8ecb5a60
/.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
/.git/objects/f6/cca8a6084310f182dc287fadbb82c5ebcfffe8
/.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
/.git/HEAD
/.git/index
/.git/config
/.git/ORIG_HEAD
/.git/FETCH_HEAD
/.git/description
/.git/COMMIT_EDITMSG
/.log/history.log
/.idea/shelf/Uncommitted_changes_before_Update_at_11_11_22,_1_29_PM_[Default]/shelved.patch
/.idea/shelf/Uncommitted_changes_before_Update_at_11_11_22__1_29_PM__Default_.xml
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2022.11.15.11.28.21.413.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2022.11.15.11.28.21.413.1 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2022.11.15.11.28.21.413.2 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2022.11.15.11.28.21.413.3 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2022.11.15.11.28.21.413.4 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Point(Point p) {
        this.x = p.x;
        this.y = p.y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns a new point that has values added to components
    public Point add(Point p) {
        return add(p.x, p.y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    public boolean isInBounds(Point min, Point max) {
        return isInBounds(min.x, min.y, max.x, max.y);
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2022.11.15.11.28.21.413.5 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSKDTree<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2022.11.15.11.28.21.415.0 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2022.11.15.11.28.21.418.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2022.11.15.11.28.21.420.0 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */

// Testing Git -- kmikels

public class PSBruteForce<Value> implements PointSearch<Value> {
    // constructor makes empty collection
    public PSBruteForce() { }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return 0; }

    // return whether the KDTree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2022.11.15.11.28.21.422.0 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }
    BST<Point, Value> kdt;
    int count=0;
    Point minimum;
    Point maximum;
    // constructor makes empty kD-tree
    public PSKDTree() {
        kdt = new BST<Point, Value>();
    }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {  //change??
        kdt.put(p,v);
        count++;
    }

    public Value get(Point p) {
        if(isEmpty()) return null;
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        if(isEmpty()) return null;
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() {
        if(isEmpty()) return null;
        return null;
    }
    public Point max() {
        if(isEmpty()) return null;
        return null;
    }

    // return the number of Points in kD-tree
    public int size() { return count; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return count==0; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2022.11.15.11.28.21.426.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2022.11.15.11.28.21.426.1 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.15.11.28.21.426.2 ]--
InitFile: /.cos265


--[ 2022.11.15.10.01.43.598.0 ]--
+ 15     BST<Point, Value> kdt;
+ 16     int count=0;
+ 17     Point minimum;
r 18     Point maximum;
+ 20     public PSKDTree() {
+ 21         kdt = new BST<Point, Value>();
r 22     }
+ 25     public void put(Point p, Value v) {  //change??
+ 26         kdt.put(p,v);
r 27         count++;
+ 31         if(isEmpty()) return null;
+ 40         if(isEmpty()) return null;
+ 65     public Point min() {
+ 66         if(isEmpty()) return null;
+ 67         return null;
+ 68     }
+ 69     public Point max() {
+ 70         if(isEmpty()) return null;
r 71         return null;
r 72     }
r 75     public int size() { return count; }
r 78     public boolean isEmpty() { return count==0; }
--[ 2022.11.15.10.01.50.183.0 ]--
UpdateTree (AD): 1 0
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22,_10_01_AM_[Changes]/shelved.patch

--[ 2022.11.15.10.01.50.192.0 ]--
UpdateTree (AD): 1 0
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22__10_01_AM__Changes_.xml

--[ 2022.11.15.10.01.53.044.0 ]--
UpdateTree (AD): 8 0
+ /.git/objects/54/0fd2392eaf74abc751e9970668bf235e56f803
+ /.git/objects/6e/e6bdaf464e0f4adb373587a385e0875ebf8ba6
+ /.git/objects/86/5b56d35df1dcfcbf5196eeddcef674c03a3a93
+ /.git/objects/8d/e804238c33c653fe535bd162aabed440497ec7
+ /.git/objects/9a/8c6aff1f8871e01cacec32f40b40f4107494d2
+ /.git/objects/c7/ed19fcb2ed6617a23bd3e9a2efaa966bed42da
+ /.git/ORIG_HEAD
+ /.git/FETCH_HEAD

--[ 2022.11.15.10.04.46.433.0 ]--
r 25     public void put(Point p, Value v) {  //change?? 
--[ 2022.11.15.10.04.47.094.0 ]--
r 25     public void put(Point p, Value v) {  //change?? r
--[ 2022.11.15.10.04.47.202.0 ]--
r 25     public void put(Point p, Value v) {  //change?? re
--[ 2022.11.15.10.04.47.438.0 ]--
r 25     public void put(Point p, Value v) {  //change?? rem
--[ 2022.11.15.10.04.47.678.0 ]--
r 25     public void put(Point p, Value v) {  //change?? reme
--[ 2022.11.15.10.04.47.839.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remem
--[ 2022.11.15.10.04.47.963.0 ]--
r 25     public void put(Point p, Value v) {  //change?? rememb
--[ 2022.11.15.10.04.48.170.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remembe
--[ 2022.11.15.10.04.48.241.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember
--[ 2022.11.15.10.04.48.337.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember 
--[ 2022.11.15.10.04.48.485.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember t
--[ 2022.11.15.10.04.48.573.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to
--[ 2022.11.15.10.04.48.654.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to 
--[ 2022.11.15.10.04.48.795.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to a
--[ 2022.11.15.10.04.48.882.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to al
--[ 2022.11.15.10.04.49.050.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alt
--[ 2022.11.15.10.04.49.191.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alte
--[ 2022.11.15.10.04.49.284.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alter
--[ 2022.11.15.10.04.49.415.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to altern
--[ 2022.11.15.10.04.49.514.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alterna
--[ 2022.11.15.10.04.49.611.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternat
--[ 2022.11.15.10.04.49.767.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate
--[ 2022.11.15.10.04.49.914.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate 
--[ 2022.11.15.10.04.50.171.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x
--[ 2022.11.15.10.04.50.250.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x 
--[ 2022.11.15.10.04.50.475.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x a
--[ 2022.11.15.10.04.50.586.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x an
--[ 2022.11.15.10.04.50.642.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and
--[ 2022.11.15.10.04.50.728.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and 
--[ 2022.11.15.10.04.50.972.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y
--[ 2022.11.15.10.04.51.114.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y 
--[ 2022.11.15.10.04.51.556.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y c
--[ 2022.11.15.10.04.51.671.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y co
--[ 2022.11.15.10.04.51.804.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coo
--[ 2022.11.15.10.04.51.882.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coor
--[ 2022.11.15.10.04.52.153.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coord
--[ 2022.11.15.10.04.52.395.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords
--[ 2022.11.15.10.04.52.531.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords 
--[ 2022.11.15.10.04.52.889.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords f
--[ 2022.11.15.10.04.52.949.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords fo
--[ 2022.11.15.10.04.53.067.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for
--[ 2022.11.15.10.04.53.156.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for 
--[ 2022.11.15.10.04.53.248.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for i
--[ 2022.11.15.10.04.53.447.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for in
--[ 2022.11.15.10.04.53.560.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for ins
--[ 2022.11.15.10.04.53.771.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for inse
--[ 2022.11.15.10.04.53.885.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for inser
--[ 2022.11.15.10.04.54.065.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for insert
--[ 2022.11.15.10.04.54.215.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for inserti
--[ 2022.11.15.10.04.54.368.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for insertin
--[ 2022.11.15.10.04.54.442.0 ]--
r 25     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for inserting
--[ 2022.11.15.10.05.17.062.0 ]--
r 32         return null; 
--[ 2022.11.15.10.05.17.324.0 ]--
r 32         return null; /
--[ 2022.11.15.10.05.17.428.0 ]--
r 32         return null; //
--[ 2022.11.15.10.05.18.866.0 ]--
r 32         return null; //s
--[ 2022.11.15.10.05.19.156.0 ]--
r 32         return null; //se
--[ 2022.11.15.10.05.19.322.0 ]--
r 32         return null; //sea
--[ 2022.11.15.10.05.19.391.0 ]--
r 32         return null; //sear
--[ 2022.11.15.10.05.19.652.0 ]--
r 32         return null; //searc
--[ 2022.11.15.10.05.19.740.0 ]--
r 32         return null; //search
--[ 2022.11.15.10.05.19.858.0 ]--
r 32         return null; //searchi
--[ 2022.11.15.10.05.19.992.0 ]--
r 32         return null; //searchin
--[ 2022.11.15.10.05.20.079.0 ]--
r 32         return null; //searching
--[ 2022.11.15.10.05.20.521.0 ]--
r 32         return null; //searchin
--[ 2022.11.15.10.05.20.642.0 ]--
r 32         return null; //searchi
--[ 2022.11.15.10.05.20.757.0 ]--
r 32         return null; //search
--[ 2022.11.15.10.05.20.990.0 ]--
r 32         return null; //search 
--[ 2022.11.15.10.05.21.130.0 ]--
r 32         return null; //search t
--[ 2022.11.15.10.05.21.191.0 ]--
r 32         return null; //search th
--[ 2022.11.15.10.05.21.340.0 ]--
r 32         return null; //search thr
--[ 2022.11.15.10.05.21.421.0 ]--
r 32         return null; //search thro
--[ 2022.11.15.10.05.21.495.0 ]--
r 32         return null; //search throu
--[ 2022.11.15.10.05.21.624.0 ]--
r 32         return null; //search throug
--[ 2022.11.15.10.05.21.732.0 ]--
r 32         return null; //search through
--[ 2022.11.15.10.05.21.872.0 ]--
r 32         return null; //search through 
--[ 2022.11.15.10.05.22.013.0 ]--
r 32         return null; //search through t
--[ 2022.11.15.10.05.22.086.0 ]--
r 32         return null; //search through th
--[ 2022.11.15.10.05.22.222.0 ]--
r 32         return null; //search through the
--[ 2022.11.15.10.05.22.334.0 ]--
r 32         return null; //search through the 
--[ 2022.11.15.10.05.22.478.0 ]--
r 32         return null; //search through the t
--[ 2022.11.15.10.05.22.640.0 ]--
r 32         return null; //search through the tr
--[ 2022.11.15.10.05.22.811.0 ]--
r 32         return null; //search through the tre
--[ 2022.11.15.10.05.22.976.0 ]--
r 32         return null; //search through the tree
--[ 2022.11.15.10.05.23.307.0 ]--
r 32         return null; //search through the tree 
--[ 2022.11.15.10.05.23.470.0 ]--
r 32         return null; //search through the tree i
--[ 2022.11.15.10.05.23.647.0 ]--
r 32         return null; //search through the tree in
--[ 2022.11.15.10.05.23.712.0 ]--
r 32         return null; //search through the tree ins
--[ 2022.11.15.10.05.23.879.0 ]--
r 32         return null; //search through the tree inst
--[ 2022.11.15.10.05.24.043.0 ]--
r 32         return null; //search through the tree inste
--[ 2022.11.15.10.05.24.220.0 ]--
r 32         return null; //search through the tree instea
--[ 2022.11.15.10.05.24.539.0 ]--
r 32         return null; //search through the tree instead
--[ 2022.11.15.10.05.24.641.0 ]--
r 32         return null; //search through the tree instead 
--[ 2022.11.15.10.05.24.814.0 ]--
r 32         return null; //search through the tree instead o
--[ 2022.11.15.10.05.24.921.0 ]--
r 32         return null; //search through the tree instead of
--[ 2022.11.15.10.05.24.991.0 ]--
r 32         return null; //search through the tree instead of 
--[ 2022.11.15.10.05.25.122.0 ]--
r 32         return null; //search through the tree instead of t
--[ 2022.11.15.10.05.25.188.0 ]--
r 32         return null; //search through the tree instead of th
--[ 2022.11.15.10.05.25.254.0 ]--
r 32         return null; //search through the tree instead of thi
--[ 2022.11.15.10.05.25.395.0 ]--
r 32         return null; //search through the tree instead of this
--[ 2022.11.15.10.05.25.560.0 ]--
r 32         return null; //search through the tree instead of this 
--[ 2022.11.15.10.05.25.702.0 ]--
r 32         return null; //search through the tree instead of this l
--[ 2022.11.15.10.05.25.821.0 ]--
r 32         return null; //search through the tree instead of this li
--[ 2022.11.15.10.05.26.095.0 ]--
r 32         return null; //search through the tree instead of this l
--[ 2022.11.15.10.05.26.215.0 ]--
r 32         return null; //search through the tree instead of this 
--[ 2022.11.15.10.05.26.341.0 ]--
r 32         return null; //search through the tree instead of this
--[ 2022.11.15.10.05.26.459.0 ]--
r 32         return null; //search through the tree instead of thi
--[ 2022.11.15.10.05.26.587.0 ]--
r 32         return null; //search through the tree instead of th
--[ 2022.11.15.10.05.26.710.0 ]--
r 32         return null; //search through the tree instead of t
--[ 2022.11.15.10.05.26.824.0 ]--
r 32         return null; //search through the tree instead of 
--[ 2022.11.15.10.05.27.282.0 ]--
r 32         return null; //search through the tree instead of r
--[ 2022.11.15.10.05.27.349.0 ]--
r 32         return null; //search through the tree instead of re
--[ 2022.11.15.10.05.27.543.0 ]--
r 32         return null; //search through the tree instead of ret
--[ 2022.11.15.10.05.27.635.0 ]--
r 32         return null; //search through the tree instead of retu
--[ 2022.11.15.10.05.28.278.0 ]--
r 32         return null; //search through the tree instead of retur
--[ 2022.11.15.10.05.28.492.0 ]--
r 32         return null; //search through the tree instead of return
--[ 2022.11.15.10.05.28.622.0 ]--
r 32         return null; //search through the tree instead of returni
--[ 2022.11.15.10.05.28.760.0 ]--
r 32         return null; //search through the tree instead of returnin
--[ 2022.11.15.10.05.28.863.0 ]--
r 32         return null; //search through the tree instead of returning
--[ 2022.11.15.10.05.28.974.0 ]--
r 32         return null; //search through the tree instead of returning 
--[ 2022.11.15.10.05.29.109.0 ]--
r 32         return null; //search through the tree instead of returning n
--[ 2022.11.15.10.05.29.285.0 ]--
r 32         return null; //search through the tree instead of returning nu
--[ 2022.11.15.10.05.29.445.0 ]--
r 32         return null; //search through the tree instead of returning nul
--[ 2022.11.15.10.05.29.547.0 ]--
r 32         return null; //search through the tree instead of returning null
--[ 2022.11.15.10.05.35.260.0 ]--
r 36         return false; 
--[ 2022.11.15.10.05.35.721.0 ]--
r 36         return false; /
--[ 2022.11.15.10.05.35.863.0 ]--
r 36         return false; //
--[ 2022.11.15.10.05.36.712.0 ]--
r 36         return false; //s
--[ 2022.11.15.10.05.36.778.0 ]--
r 36         return false; //se
--[ 2022.11.15.10.05.36.973.0 ]--
r 36         return false; //sea
--[ 2022.11.15.10.05.37.058.0 ]--
r 36         return false; //sear
--[ 2022.11.15.10.05.37.369.0 ]--
r 36         return false; //searc
--[ 2022.11.15.10.05.37.452.0 ]--
r 36         return false; //search
--[ 2022.11.15.10.05.37.539.0 ]--
r 36         return false; //searchi
--[ 2022.11.15.10.05.37.735.0 ]--
r 36         return false; //searchin
--[ 2022.11.15.10.05.37.851.0 ]--
r 36         return false; //searching
--[ 2022.11.15.10.05.41.328.0 ]--
r 36         return false; //searching 
--[ 2022.11.15.10.05.41.439.0 ]--
r 36         return false; //searching a
--[ 2022.11.15.10.05.41.596.0 ]--
r 36         return false; //searching ag
--[ 2022.11.15.10.05.41.720.0 ]--
r 36         return false; //searching aga
--[ 2022.11.15.10.05.41.832.0 ]--
r 36         return false; //searching agai
--[ 2022.11.15.10.05.41.960.0 ]--
r 36         return false; //searching again
--[ 2022.11.15.10.05.42.133.0 ]--
r 36         return false; //searching again 
--[ 2022.11.15.10.05.46.320.0 ]--
r 36         return false; //searching again f
--[ 2022.11.15.10.05.46.407.0 ]--
r 36         return false; //searching again fo
--[ 2022.11.15.10.05.46.502.0 ]--
r 36         return false; //searching again for
--[ 2022.11.15.10.05.46.625.0 ]--
r 36         return false; //searching again for 
--[ 2022.11.15.10.05.46.803.0 ]--
r 36         return false; //searching again for p
--[ 2022.11.15.10.05.47.133.0 ]--
r 36         return false; //searching again for p 
--[ 2022.11.15.10.05.47.251.0 ]--
r 36         return false; //searching again for p i
--[ 2022.11.15.10.05.47.410.0 ]--
r 36         return false; //searching again for p in
--[ 2022.11.15.10.05.47.518.0 ]--
r 36         return false; //searching again for p in 
--[ 2022.11.15.10.05.47.645.0 ]--
r 36         return false; //searching again for p in t
--[ 2022.11.15.10.05.47.732.0 ]--
r 36         return false; //searching again for p in th
--[ 2022.11.15.10.05.47.828.0 ]--
r 36         return false; //searching again for p in the
--[ 2022.11.15.10.05.47.930.0 ]--
r 36         return false; //searching again for p in the 
--[ 2022.11.15.10.05.48.170.0 ]--
r 36         return false; //searching again for p in the b
--[ 2022.11.15.10.05.48.340.0 ]--
r 36         return false; //searching again for p in the bs
--[ 2022.11.15.10.05.48.487.0 ]--
r 36         return false; //searching again for p in the bst
--[ 2022.11.15.10.06.34.753.0 ]--
r 45     public Iterable<Point> points() { return null; } 
--[ 2022.11.15.10.06.35.179.0 ]--
r 45     public Iterable<Point> points() { return null; } /
--[ 2022.11.15.10.06.35.357.0 ]--
r 45     public Iterable<Point> points() { return null; } //
--[ 2022.11.15.10.06.36.066.0 ]--
r 45     public Iterable<Point> points() { return null; } //m
--[ 2022.11.15.10.06.36.166.0 ]--
r 45     public Iterable<Point> points() { return null; } //ma
--[ 2022.11.15.10.06.36.445.0 ]--
r 45     public Iterable<Point> points() { return null; } //mak
--[ 2022.11.15.10.06.36.599.0 ]--
r 45     public Iterable<Point> points() { return null; } //make
--[ 2022.11.15.10.06.37.033.0 ]--
r 45     public Iterable<Point> points() { return null; } //make 
--[ 2022.11.15.10.06.38.493.0 ]--
r 45     public Iterable<Point> points() { return null; } //make
--[ 2022.11.15.10.06.38.628.0 ]--
r 45     public Iterable<Point> points() { return null; } //mak
--[ 2022.11.15.10.06.38.773.0 ]--
r 45     public Iterable<Point> points() { return null; } //ma
--[ 2022.11.15.10.06.38.939.0 ]--
r 45     public Iterable<Point> points() { return null; } //m
--[ 2022.11.15.10.06.39.076.0 ]--
r 45     public Iterable<Point> points() { return null; } //
--[ 2022.11.15.10.06.39.180.0 ]--
r 45     public Iterable<Point> points() { return null; } /
--[ 2022.11.15.10.06.39.743.0 ]--
r 45     public Iterable<Point> points() { return null; } 
--[ 2022.11.15.10.06.46.838.0 ]--
r 45     public Iterable<Point> points() { return null; } /
--[ 2022.11.15.10.06.47.015.0 ]--
r 45     public Iterable<Point> points() { return null; } //
--[ 2022.11.15.10.06.48.250.0 ]--
r 45     public Iterable<Point> points() { return null; } /
--[ 2022.11.15.10.06.48.393.0 ]--
r 45     public Iterable<Point> points() { return null; } 
--[ 2022.11.15.10.06.51.850.0 ]--
+ 28         
--[ 2022.11.15.10.06.54.733.0 ]--
+ 17     
--[ 2022.11.15.10.07.59.546.0 ]--
r 17 
r 29 
r 47     public Iterable<Point> points() { return null; }
--[ 2022.11.15.10.08.18.813.0 ]--
r 47     public Iterable<Point> points() { return null; } 
--[ 2022.11.15.10.08.19.078.0 ]--
r 47     public Iterable<Point> points() { return null; } /
--[ 2022.11.15.10.08.19.221.0 ]--
r 47     public Iterable<Point> points() { return null; } //
--[ 2022.11.15.10.08.21.923.0 ]--
r 47     public Iterable<Point> points() { return null; } //d
--[ 2022.11.15.10.08.22.033.0 ]--
r 47     public Iterable<Point> points() { return null; } //do
--[ 2022.11.15.10.08.22.178.0 ]--
r 47     public Iterable<Point> points() { return null; } //do 
--[ 2022.11.15.10.08.22.364.0 ]--
r 47     public Iterable<Point> points() { return null; } //do w
--[ 2022.11.15.10.08.22.437.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we
--[ 2022.11.15.10.08.22.553.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we 
--[ 2022.11.15.10.08.23.206.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we h
--[ 2022.11.15.10.08.23.326.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we ha
--[ 2022.11.15.10.08.23.494.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we hav
--[ 2022.11.15.10.08.23.656.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have
--[ 2022.11.15.10.08.23.791.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have 
--[ 2022.11.15.10.08.23.887.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have t
--[ 2022.11.15.10.08.23.994.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have to
--[ 2022.11.15.10.08.24.085.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have to 
--[ 2022.11.15.10.08.24.245.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have to a
--[ 2022.11.15.10.08.24.457.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have to ac
--[ 2022.11.15.10.08.24.612.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have to acc
--[ 2022.11.15.10.08.24.770.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have to acco
--[ 2022.11.15.10.08.24.840.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have to accou
--[ 2022.11.15.10.08.25.081.0 ]--
r 47     public Iterable<Point> points() { return null; } //do we have to account
--[ 2022.11.15.10.08.29.204.0 ]--
r 47     public Iterable<Point> points() { return null; } //account
--[ 2022.11.15.10.08.30.625.0 ]--
r 47     public Iterable<Point> points() { return null; } //account 
--[ 2022.11.15.10.08.30.783.0 ]--
r 47     public Iterable<Point> points() { return null; } //account f
--[ 2022.11.15.10.08.30.888.0 ]--
r 47     public Iterable<Point> points() { return null; } //account fo
--[ 2022.11.15.10.08.30.983.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for
--[ 2022.11.15.10.08.31.087.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for 
--[ 2022.11.15.10.08.31.205.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for d
--[ 2022.11.15.10.08.31.401.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for de
--[ 2022.11.15.10.08.31.453.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for del
--[ 2022.11.15.10.08.31.615.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for dele
--[ 2022.11.15.10.08.31.882.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for delet
--[ 2022.11.15.10.08.32.210.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for deleti
--[ 2022.11.15.10.08.32.276.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for deletio
--[ 2022.11.15.10.08.32.470.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for deletion
--[ 2022.11.15.10.08.32.582.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for deletions
--[ 2022.11.15.10.08.32.802.0 ]--
r 47     public Iterable<Point> points() { return null; } //account for deletions?
--[ 2022.11.15.10.11.04.177.0 ]--
:/src/PSBruteForce.java
r 8 // T
--[ 2022.11.15.10.11.04.307.0 ]--
r 8 // 
--[ 2022.11.15.10.11.04.631.0 ]--
r 8 // r
--[ 2022.11.15.10.11.04.701.0 ]--
r 8 // re
--[ 2022.11.15.10.11.05.062.0 ]--
r 8 // red
--[ 2022.11.15.10.11.05.629.0 ]--
r 8 // red-
--[ 2022.11.15.10.11.06.017.0 ]--
r 8 // red-b
--[ 2022.11.15.10.11.06.134.0 ]--
r 8 // red-bl
--[ 2022.11.15.10.11.06.333.0 ]--
r 8 // red-bla
--[ 2022.11.15.10.11.06.553.0 ]--
r 8 // red-blac
--[ 2022.11.15.10.11.06.668.0 ]--
r 8 // red-black
--[ 2022.11.15.10.11.06.894.0 ]--
r 8 // red-black 
--[ 2022.11.15.10.11.07.089.0 ]--
r 8 // red-black t
--[ 2022.11.15.10.11.07.232.0 ]--
r 8 // red-black tr
--[ 2022.11.15.10.11.07.520.0 ]--
r 8 // red-black tre
--[ 2022.11.15.10.11.07.667.0 ]--
r 8 // red-black tree
--[ 2022.11.15.10.11.07.860.0 ]--
r 8 // red-black trees
--[ 2022.11.15.10.13.02.548.0 ]--
+ 12     public PSBruteForce() { 
r 13     }
--[ 2022.11.15.10.13.02.602.0 ]--
+ 13         
--[ 2022.11.15.10.13.08.451.0 ]--
+ 12     
--[ 2022.11.15.10.13.09.264.0 ]--
+ 12     
--[ 2022.11.15.10.14.15.390.0 ]--
r 13     RedBlackBST<String, Integer> st = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.15.401.0 ]--
r 12 
--[ 2022.11.15.10.14.18.870.0 ]--
r 13     RedBlackBST<String, Integer> rst = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.19.094.0 ]--
r 13     RedBlackBST<String, Integer> rbst = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.23.948.0 ]--
r 13     RedBlackBST<String, Integer> rbst;
--[ 2022.11.15.10.14.26.655.0 ]--
r 15         RedBlackBST<String, Integer> st = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.26.669.0 ]--
r 14     public PSBruteForce() {
--[ 2022.11.15.10.14.30.726.0 ]--
r 15         st = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.31.552.0 ]--
r 15         s = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.31.628.0 ]--
r 15          = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.32.054.0 ]--
r 15         r = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.32.355.0 ]--
r 15         rg = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.32.642.0 ]--
r 15         r = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.32.718.0 ]--
r 15         rb = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.32.911.0 ]--
r 15         rbs = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.33.172.0 ]--
r 15         rbst = new RedBlackBST<String, Integer>();
--[ 2022.11.15.10.14.38.152.0 ]--
r 15         rbst = new RedBlackBST<>();
--[ 2022.11.15.10.14.58.456.0 ]--
r 13     RedBlackBST<P, Integer> rbst;
--[ 2022.11.15.10.14.58.693.0 ]--
r 13     RedBlackBST<Po, Integer> rbst;
--[ 2022.11.15.10.14.58.797.0 ]--
r 13     RedBlackBST<Poi, Integer> rbst;
--[ 2022.11.15.10.14.59.006.0 ]--
r 13     RedBlackBST<Poin, Integer> rbst;
--[ 2022.11.15.10.14.59.137.0 ]--
r 13     RedBlackBST<Point, Integer> rbst;
--[ 2022.11.15.10.15.00.464.0 ]--
r 13     RedBlackBST<Point, V> rbst;
--[ 2022.11.15.10.15.00.637.0 ]--
r 13     RedBlackBST<Point, Va> rbst;
--[ 2022.11.15.10.15.00.842.0 ]--
r 13     RedBlackBST<Point, Val> rbst;
--[ 2022.11.15.10.15.00.908.0 ]--
r 13     RedBlackBST<Point, Valu> rbst;
--[ 2022.11.15.10.15.01.001.0 ]--
r 13     RedBlackBST<Point, Value> rbst;
--[ 2022.11.15.10.15.07.757.0 ]--
+ 20         
--[ 2022.11.15.10.15.09.902.0 ]--
r 20         r
--[ 2022.11.15.10.15.10.142.0 ]--
r 20         rb
--[ 2022.11.15.10.15.10.322.0 ]--
r 20         rbs
--[ 2022.11.15.10.15.10.495.0 ]--
r 20         rbst
--[ 2022.11.15.10.15.10.684.0 ]--
r 20         rbst.
--[ 2022.11.15.10.15.13.219.0 ]--
r 20         rbst.put
--[ 2022.11.15.10.15.13.233.0 ]--
r 20         rbst.put()
--[ 2022.11.15.10.15.13.237.0 ]--
r 20         rbst.put();
--[ 2022.11.15.10.15.14.732.0 ]--
r 20         rbst.put(p);
--[ 2022.11.15.10.15.14.988.0 ]--
r 20         rbst.put(p,);
--[ 2022.11.15.10.15.15.172.0 ]--
r 20         rbst.put(p,v);
--[ 2022.11.15.10.15.16.674.0 ]--
+ 20         rbst.put(p,v)
r 21         ;
--[ 2022.11.15.10.15.17.358.0 ]--
- 20
r 20         rbst.put(p,v);
--[ 2022.11.15.10.15.17.507.0 ]--
r 20         rbst.put(p,v;
--[ 2022.11.15.10.15.18.596.0 ]--
r 20         rbst.put(p,v);
--[ 2022.11.15.10.15.43.292.0 ]--
r 24         return r;
--[ 2022.11.15.10.15.43.584.0 ]--
r 24         return rb;
--[ 2022.11.15.10.15.43.790.0 ]--
r 24         return rbs;
--[ 2022.11.15.10.15.43.974.0 ]--
r 24         return rbst;
--[ 2022.11.15.10.15.44.291.0 ]--
r 24         return rbst.;
--[ 2022.11.15.10.15.44.951.0 ]--
r 24         return rbst.get;
--[ 2022.11.15.10.15.44.957.0 ]--
r 24         return rbst.get();
--[ 2022.11.15.10.15.45.740.0 ]--
r 24         return rbst.get(p);
--[ 2022.11.15.10.15.51.563.0 ]--
r 28         return r;
--[ 2022.11.15.10.15.51.750.0 ]--
r 28         return rb;
--[ 2022.11.15.10.15.51.937.0 ]--
r 28         return rbs;
--[ 2022.11.15.10.15.52.139.0 ]--
r 28         return rbst;
--[ 2022.11.15.10.15.54.436.0 ]--
r 28         return rbst.contains;
--[ 2022.11.15.10.15.54.451.0 ]--
r 28         return rbst;;
--[ 2022.11.15.10.15.54.461.0 ]--
r 28         return rbst.contains;
--[ 2022.11.15.10.15.54.466.0 ]--
r 28         return rbst.contains();
--[ 2022.11.15.10.15.55.404.0 ]--
r 28         return rbst.contains(p);
--[ 2022.11.15.10.16.32.667.0 ]--
r 32     public Iterable<Point> points() { 
--[ 2022.11.15.10.16.32.833.0 ]--
r 32     public Iterable<Point> points() { /
--[ 2022.11.15.10.16.32.984.0 ]--
r 32     public Iterable<Point> points() { //
--[ 2022.11.15.10.16.33.673.0 ]--
r 32     public Iterable<Point> points() { //d
--[ 2022.11.15.10.16.33.848.0 ]--
r 32     public Iterable<Point> points() { //de
--[ 2022.11.15.10.16.33.935.0 ]--
r 32     public Iterable<Point> points() { //del
--[ 2022.11.15.10.16.34.048.0 ]--
r 32     public Iterable<Point> points() { //dele
--[ 2022.11.15.10.16.34.243.0 ]--
r 32     public Iterable<Point> points() { //delet
--[ 2022.11.15.10.16.34.491.0 ]--
r 32     public Iterable<Point> points() { //deleti
--[ 2022.11.15.10.16.34.567.0 ]--
r 32     public Iterable<Point> points() { //deletio
--[ 2022.11.15.10.16.34.730.0 ]--
r 32     public Iterable<Point> points() { //deletion
--[ 2022.11.15.10.16.35.062.0 ]--
r 32     public Iterable<Point> points() { //deletions
--[ 2022.11.15.10.16.35.389.0 ]--
r 32     public Iterable<Point> points() { //deletions?
--[ 2022.11.15.10.16.55.850.0 ]--
+ 49     public Point min() { 
r 50         return null; }
--[ 2022.11.15.10.16.57.445.0 ]--
+ 50         return null; 
r 51     }
--[ 2022.11.15.10.16.59.730.0 ]--
+ 50         
--[ 2022.11.15.10.17.03.956.0 ]--
r 50         /
--[ 2022.11.15.10.17.04.052.0 ]--
r 50         //
--[ 2022.11.15.10.17.04.840.0 ]--
r 50         //i
--[ 2022.11.15.10.17.04.933.0 ]--
r 50         //it
--[ 2022.11.15.10.17.05.078.0 ]--
r 50         //ite
--[ 2022.11.15.10.17.05.149.0 ]--
r 50         //iter
--[ 2022.11.15.10.17.05.388.0 ]--
r 50         //itera
--[ 2022.11.15.10.17.05.623.0 ]--
r 50         //iterab
--[ 2022.11.15.10.17.05.760.0 ]--
r 50         //iterabl
--[ 2022.11.15.10.17.05.847.0 ]--
r 50         //iterable
--[ 2022.11.15.10.17.09.589.0 ]--
+ 51         
--[ 2022.11.15.10.17.12.728.0 ]--
r 50         //fiterable
--[ 2022.11.15.10.17.12.861.0 ]--
r 50         //foiterable
--[ 2022.11.15.10.17.12.916.0 ]--
r 50         //foriterable
--[ 2022.11.15.10.17.13.030.0 ]--
r 50         //for iterable
--[ 2022.11.15.10.17.13.223.0 ]--
r 50         //for eiterable
--[ 2022.11.15.10.17.13.427.0 ]--
r 50         //for eaiterable
--[ 2022.11.15.10.17.13.620.0 ]--
r 50         //for eaciterable
--[ 2022.11.15.10.17.13.716.0 ]--
r 50         //for eachiterable
--[ 2022.11.15.10.17.13.821.0 ]--
r 50         //for each iterable
--[ 2022.11.15.10.17.14.967.0 ]--
r 50         //for each iterable 
--[ 2022.11.15.10.17.15.087.0 ]--
r 50         //for each iterable l
--[ 2022.11.15.10.17.15.253.0 ]--
r 50         //for each iterable lo
--[ 2022.11.15.10.17.15.356.0 ]--
r 50         //for each iterable loo
--[ 2022.11.15.10.17.15.564.0 ]--
r 50         //for each iterable loop
--[ 2022.11.15.10.17.15.844.0 ]--
r 50         //for each iterable loop,
--[ 2022.11.15.10.17.15.989.0 ]--
r 50         //for each iterable loop, 
--[ 2022.11.15.10.17.16.180.0 ]--
r 50         //for each iterable loop, r
--[ 2022.11.15.10.17.16.254.0 ]--
r 50         //for each iterable loop, re
--[ 2022.11.15.10.17.16.361.0 ]--
r 50         //for each iterable loop, rem
--[ 2022.11.15.10.17.16.471.0 ]--
r 50         //for each iterable loop, reme
--[ 2022.11.15.10.17.16.521.0 ]--
r 50         //for each iterable loop, remem
--[ 2022.11.15.10.17.16.747.0 ]--
r 50         //for each iterable loop, rememb
--[ 2022.11.15.10.17.16.911.0 ]--
r 50         //for each iterable loop, remembe
--[ 2022.11.15.10.17.16.995.0 ]--
r 50         //for each iterable loop, remember
--[ 2022.11.15.10.17.17.084.0 ]--
r 50         //for each iterable loop, remember 
--[ 2022.11.15.10.17.17.199.0 ]--
r 50         //for each iterable loop, remember t
--[ 2022.11.15.10.17.17.254.0 ]--
r 50         //for each iterable loop, remember th
--[ 2022.11.15.10.17.17.347.0 ]--
r 50         //for each iterable loop, remember the
--[ 2022.11.15.10.17.17.421.0 ]--
r 50         //for each iterable loop, remember the 
--[ 2022.11.15.10.17.17.597.0 ]--
r 50         //for each iterable loop, remember the m
--[ 2022.11.15.10.17.17.696.0 ]--
r 50         //for each iterable loop, remember the mi
--[ 2022.11.15.10.17.17.804.0 ]--
r 50         //for each iterable loop, remember the min
--[ 2022.11.15.10.17.19.762.0 ]--
+ 54     public Point max() { 
r 55         return null; }
--[ 2022.11.15.10.17.21.298.0 ]--
+ 55         return null; 
r 56     }
--[ 2022.11.15.10.17.23.544.0 ]--
+ 55         
--[ 2022.11.15.10.17.24.455.0 ]--
r 55         /
--[ 2022.11.15.10.17.24.568.0 ]--
r 55         //
--[ 2022.11.15.10.17.24.904.0 ]--
r 55         // 
--[ 2022.11.15.10.17.25.035.0 ]--
r 55         // s
--[ 2022.11.15.10.17.25.202.0 ]--
r 55         // sa
--[ 2022.11.15.10.17.25.313.0 ]--
r 55         // sam
--[ 2022.11.15.10.17.25.426.0 ]--
r 55         // same
--[ 2022.11.15.10.17.25.537.0 ]--
r 55         // same 
--[ 2022.11.15.10.17.25.774.0 ]--
r 55         // same a
--[ 2022.11.15.10.17.25.920.0 ]--
r 55         // same as
--[ 2022.11.15.10.17.26.041.0 ]--
r 55         // same as 
--[ 2022.11.15.10.17.26.214.0 ]--
r 55         // same as m
--[ 2022.11.15.10.17.26.332.0 ]--
r 55         // same as mi
--[ 2022.11.15.10.17.26.448.0 ]--
r 55         // same as min
--[ 2022.11.15.10.17.26.714.0 ]--
r 55         // same as min,
--[ 2022.11.15.10.17.26.818.0 ]--
r 55         // same as min, 
--[ 2022.11.15.10.17.27.591.0 ]--
r 55         // same as min, b
--[ 2022.11.15.10.17.27.669.0 ]--
r 55         // same as min, bu
--[ 2022.11.15.10.17.27.773.0 ]--
r 55         // same as min, but
--[ 2022.11.15.10.17.27.862.0 ]--
r 55         // same as min, but 
--[ 2022.11.15.10.17.28.358.0 ]--
r 55         // same as min, but w
--[ 2022.11.15.10.17.28.466.0 ]--
r 55         // same as min, but wi
--[ 2022.11.15.10.17.28.636.0 ]--
r 55         // same as min, but wit
--[ 2022.11.15.10.17.28.744.0 ]--
r 55         // same as min, but with
--[ 2022.11.15.10.17.28.884.0 ]--
r 55         // same as min, but with 
--[ 2022.11.15.10.17.29.045.0 ]--
r 55         // same as min, but with m
--[ 2022.11.15.10.17.29.168.0 ]--
r 55         // same as min, but with ma
--[ 2022.11.15.10.17.29.492.0 ]--
r 55         // same as min, but with max
--[ 2022.11.15.10.17.32.499.0 ]--
r 55         //same as min, but with max
--[ 2022.11.15.10.18.53.917.0 ]--
r 32     public Iterable<Point> points() { 
--[ 2022.11.15.10.18.57.757.0 ]--
r 33         return r;
--[ 2022.11.15.10.18.58.017.0 ]--
r 33         return rb;
--[ 2022.11.15.10.18.58.183.0 ]--
r 33         return rbs;
--[ 2022.11.15.10.18.58.369.0 ]--
r 33         return rbst;
--[ 2022.11.15.10.18.58.549.0 ]--
r 33         return rbst.;
--[ 2022.11.15.10.19.00.181.0 ]--
r 33         return rbst.keys;
--[ 2022.11.15.10.19.00.187.0 ]--
r 33         return rbst.keys();
--[ 2022.11.15.10.19.16.680.0 ]--
r 51         r
--[ 2022.11.15.10.19.17.306.0 ]--
r 51         
--[ 2022.11.15.10.19.17.667.0 ]--
r 51         f
--[ 2022.11.15.10.19.17.752.0 ]--
r 51         fo
--[ 2022.11.15.10.19.17.839.0 ]--
r 51         for
--[ 2022.11.15.10.19.18.014.0 ]--
r 51         for 
--[ 2022.11.15.10.19.18.498.0 ]--
r 51         for
--[ 2022.11.15.10.19.18.972.0 ]--
r 51         for()
--[ 2022.11.15.10.19.19.833.0 ]--
r 51         for( )
--[ 2022.11.15.10.19.24.305.0 ]--
r 51         for( V)
--[ 2022.11.15.10.19.24.628.0 ]--
r 51         for( )
--[ 2022.11.15.10.19.25.093.0 ]--
r 51         for( P)
--[ 2022.11.15.10.19.25.410.0 ]--
r 51         for( Po)
--[ 2022.11.15.10.19.25.535.0 ]--
r 51         for( Poi)
--[ 2022.11.15.10.19.25.751.0 ]--
r 51         for( Poin)
--[ 2022.11.15.10.19.25.858.0 ]--
r 51         for( Point)
--[ 2022.11.15.10.19.26.809.0 ]--
r 51         for( Point )
--[ 2022.11.15.10.19.26.938.0 ]--
r 51         for( Point p)
--[ 2022.11.15.10.19.27.613.0 ]--
r 51         for( Point p )
--[ 2022.11.15.10.19.27.732.0 ]--
r 51         for( Point p :)
--[ 2022.11.15.10.19.28.051.0 ]--
r 51         for( Point p : )
--[ 2022.11.15.10.19.29.311.0 ]--
r 51         for( Point p : r)
--[ 2022.11.15.10.19.29.493.0 ]--
r 51         for( Point p : rb)
--[ 2022.11.15.10.19.29.694.0 ]--
r 51         for( Point p : rbs)
--[ 2022.11.15.10.19.29.870.0 ]--
r 51         for( Point p : rbst)
--[ 2022.11.15.10.19.30.063.0 ]--
r 51         for( Point p : rbst.)
--[ 2022.11.15.10.19.30.704.0 ]--
r 51         for( Point p : rbst.keys)
--[ 2022.11.15.10.19.30.711.0 ]--
r 51         for( Point p : rbst.keys())
--[ 2022.11.15.10.19.32.055.0 ]--
r 51         for( Point p : rbst.keys()) 
--[ 2022.11.15.10.19.32.347.0 ]--
r 51         for( Point p : rbst.keys()) {
--[ 2022.11.15.10.19.32.556.0 ]--
+ 52 
+ 53 }
--[ 2022.11.15.10.19.32.575.0 ]--
r 53         }
--[ 2022.11.15.10.19.32.589.0 ]--
r 52             
--[ 2022.11.15.10.19.41.563.0 ]--
+ 51         
--[ 2022.11.15.10.19.43.651.0 ]--
r 51         m
--[ 2022.11.15.10.19.44.125.0 ]--
r 51         
--[ 2022.11.15.10.19.45.110.0 ]--
r 51         P
--[ 2022.11.15.10.19.45.367.0 ]--
r 51         Po
--[ 2022.11.15.10.19.45.568.0 ]--
r 51         Poi
--[ 2022.11.15.10.19.45.794.0 ]--
r 51         Poin
--[ 2022.11.15.10.19.45.952.0 ]--
r 51         Point
--[ 2022.11.15.10.19.46.366.0 ]--
r 51         Point 
--[ 2022.11.15.10.19.46.560.0 ]--
r 51         Point m
--[ 2022.11.15.10.19.46.679.0 ]--
r 51         Point mi
--[ 2022.11.15.10.19.46.787.0 ]--
r 51         Point min
--[ 2022.11.15.10.19.47.415.0 ]--
r 51         Point min;
--[ 2022.11.15.10.19.49.272.0 ]--
r 51         Point min ;
--[ 2022.11.15.10.19.49.429.0 ]--
r 51         Point min =;
--[ 2022.11.15.10.19.49.508.0 ]--
r 51         Point min = ;
--[ 2022.11.15.10.19.50.008.0 ]--
r 51         Point min = n;
--[ 2022.11.15.10.19.50.189.0 ]--
r 51         Point min = nu;
--[ 2022.11.15.10.19.50.342.0 ]--
r 51         Point min = nul;
--[ 2022.11.15.10.19.50.463.0 ]--
r 51         Point min = null;
--[ 2022.11.15.10.19.53.425.0 ]--
r 53             i
--[ 2022.11.15.10.19.53.487.0 ]--
r 53             if
--[ 2022.11.15.10.19.54.436.0 ]--
r 53             if()
--[ 2022.11.15.10.19.56.635.0 ]--
r 53             if(m)
--[ 2022.11.15.10.19.56.768.0 ]--
r 53             if(mi)
--[ 2022.11.15.10.19.56.917.0 ]--
r 53             if(min)
--[ 2022.11.15.10.19.57.309.0 ]--
r 53             if(min )
--[ 2022.11.15.10.19.57.535.0 ]--
r 53             if(min =)
--[ 2022.11.15.10.19.57.635.0 ]--
r 53             if(min ==)
--[ 2022.11.15.10.19.57.768.0 ]--
r 53             if(min == )
--[ 2022.11.15.10.19.57.983.0 ]--
r 53             if(min == n)
--[ 2022.11.15.10.19.58.172.0 ]--
r 53             if(min == nu)
--[ 2022.11.15.10.19.58.342.0 ]--
r 53             if(min == nul)
--[ 2022.11.15.10.19.58.451.0 ]--
r 53             if(min == null)
--[ 2022.11.15.10.19.59.450.0 ]--
r 53             if(min == null) 
--[ 2022.11.15.10.20.00.449.0 ]--
r 53             if(min == null) m
--[ 2022.11.15.10.20.00.627.0 ]--
r 53             if(min == null) mi
--[ 2022.11.15.10.20.00.741.0 ]--
r 53             if(min == null) min
--[ 2022.11.15.10.20.00.924.0 ]--
r 53             if(min == null) min 
--[ 2022.11.15.10.20.01.559.0 ]--
r 53             if(min == null) min =
--[ 2022.11.15.10.20.01.705.0 ]--
r 53             if(min == null) min = 
--[ 2022.11.15.10.20.02.668.0 ]--
r 53             if(min == null) min = p
--[ 2022.11.15.10.20.03.101.0 ]--
r 53             if(min == null) min = p;
--[ 2022.11.15.10.20.03.588.0 ]--
+ 54             
--[ 2022.11.15.10.20.06.055.0 ]--
r 54             i
--[ 2022.11.15.10.20.06.101.0 ]--
r 54             if
--[ 2022.11.15.10.20.06.225.0 ]--
r 54             if 
--[ 2022.11.15.10.20.07.389.0 ]--
r 54             if
--[ 2022.11.15.10.20.07.745.0 ]--
r 54             i
--[ 2022.11.15.10.20.07.863.0 ]--
r 54             
--[ 2022.11.15.10.20.09.772.0 ]--
r 54             p
--[ 2022.11.15.10.20.10.150.0 ]--
r 54             p.
--[ 2022.11.15.10.20.10.429.0 ]--
r 54             p.c
--[ 2022.11.15.10.20.10.467.0 ]--
r 54             p.co
--[ 2022.11.15.10.20.10.648.0 ]--
r 54             p.com
--[ 2022.11.15.10.20.10.798.0 ]--
r 54             p.comp
--[ 2022.11.15.10.20.10.901.0 ]--
r 54             p.compa
--[ 2022.11.15.10.20.10.979.0 ]--
r 54             p.compar
--[ 2022.11.15.10.20.11.302.0 ]--
r 54             p.compare
--[ 2022.11.15.10.20.11.922.0 ]--
r 54             p.compar
--[ 2022.11.15.10.20.12.025.0 ]--
r 54             p.compa
--[ 2022.11.15.10.20.12.136.0 ]--
r 54             p.comp
--[ 2022.11.15.10.20.12.255.0 ]--
r 54             p.com
--[ 2022.11.15.10.20.12.387.0 ]--
r 54             p.co
--[ 2022.11.15.10.20.12.520.0 ]--
r 54             p.c
--[ 2022.11.15.10.20.12.645.0 ]--
r 54             p.
--[ 2022.11.15.10.20.12.779.0 ]--
r 54             p
--[ 2022.11.15.10.20.12.897.0 ]--
r 54             
--[ 2022.11.15.10.20.13.344.0 ]--
r 54             m
--[ 2022.11.15.10.20.13.545.0 ]--
r 54             mi
--[ 2022.11.15.10.20.13.762.0 ]--
r 54             min
--[ 2022.11.15.10.20.14.116.0 ]--
r 54             min.
--[ 2022.11.15.10.20.14.472.0 ]--
r 54             min.c
--[ 2022.11.15.10.20.15.028.0 ]--
r 54             min.compareTo
--[ 2022.11.15.10.20.15.035.0 ]--
r 54             min.compareTo()
--[ 2022.11.15.10.20.15.917.0 ]--
r 54             min.compareTo(p)
--[ 2022.11.15.10.20.17.698.0 ]--
r 54             min.compareTo(p) 
--[ 2022.11.15.10.20.18.925.0 ]--
r 54             min.compareTo(p) <
--[ 2022.11.15.10.20.19.590.0 ]--
r 54             min.compareTo(p) <0
--[ 2022.11.15.10.20.20.000.0 ]--
r 54             min.compareTo(p) <
--[ 2022.11.15.10.20.20.064.0 ]--
r 54             min.compareTo(p) < 
--[ 2022.11.15.10.20.20.232.0 ]--
r 54             min.compareTo(p) < 0
--[ 2022.11.15.10.20.25.321.0 ]--
r 54             min.compareTo(p) < 0)
--[ 2022.11.15.10.20.26.671.0 ]--
r 54             imin.compareTo(p) < 0)
--[ 2022.11.15.10.20.26.784.0 ]--
r 54             ifmin.compareTo(p) < 0)
--[ 2022.11.15.10.20.27.013.0 ]--
r 54             if(min.compareTo(p) < 0)
--[ 2022.11.15.10.20.28.567.0 ]--
r 54             if(min.compareTo(p) < 0) 
--[ 2022.11.15.10.20.34.839.0 ]--
r 54             if(min.compareTo(p)  0) 
--[ 2022.11.15.10.20.35.240.0 ]--
r 54             if(min.compareTo(p) > 0) 
--[ 2022.11.15.10.20.37.466.0 ]--
r 54             if(min.compareTo(p) > 0) m
--[ 2022.11.15.10.20.37.587.0 ]--
r 54             if(min.compareTo(p) > 0) mi
--[ 2022.11.15.10.20.37.725.0 ]--
r 54             if(min.compareTo(p) > 0) min
--[ 2022.11.15.10.20.37.901.0 ]--
r 54             if(min.compareTo(p) > 0) min 
--[ 2022.11.15.10.20.38.167.0 ]--
r 54             if(min.compareTo(p) > 0) min =
--[ 2022.11.15.10.20.38.409.0 ]--
r 54             if(min.compareTo(p) > 0) min = 
--[ 2022.11.15.10.20.38.658.0 ]--
r 54             if(min.compareTo(p) > 0) min = p
--[ 2022.11.15.10.20.39.032.0 ]--
r 54             if(min.compareTo(p) > 0) min = pl
--[ 2022.11.15.10.20.39.529.0 ]--
r 54             if(min.compareTo(p) > 0) min = p
--[ 2022.11.15.10.20.39.884.0 ]--
r 54             if(min.compareTo(p) > 0) min = p;
--[ 2022.11.15.10.20.53.738.0 ]--
r 56         return m; 
--[ 2022.11.15.10.20.53.845.0 ]--
r 56         return mi; 
--[ 2022.11.15.10.20.53.975.0 ]--
r 56         return min; 
--[ 2022.11.15.10.20.59.117.0 ]--
+ 60         Point min = null;
+ 61         for( Point p : rbst.keys()) {
+ 62             if(min == null) min = p;
+ 63             if(min.compareTo(p) > 0) min = p;
+ 64         }
r 65         return min; 
--[ 2022.11.15.10.20.59.136.0 ]--
r 65         return min;
--[ 2022.11.15.10.21.01.111.0 ]--
r 60         Point m = null;
--[ 2022.11.15.10.21.01.226.0 ]--
r 60         Point ma = null;
--[ 2022.11.15.10.21.01.414.0 ]--
r 60         Point max = null;
--[ 2022.11.15.10.21.03.361.0 ]--
r 62             if(min == null) m = p;
--[ 2022.11.15.10.21.03.455.0 ]--
r 62             if(min == null) ma = p;
--[ 2022.11.15.10.21.03.687.0 ]--
r 62             if(min == null) max = p;
--[ 2022.11.15.10.21.04.938.0 ]--
r 62             if(m == null) max = p;
--[ 2022.11.15.10.21.05.019.0 ]--
r 62             if(ma == null) max = p;
--[ 2022.11.15.10.21.05.183.0 ]--
r 62             if(max == null) max = p;
--[ 2022.11.15.10.21.07.010.0 ]--
r 63             if(min.compareTo(p) > 0) m = p;
--[ 2022.11.15.10.21.07.096.0 ]--
r 63             if(min.compareTo(p) > 0) ma = p;
--[ 2022.11.15.10.21.07.269.0 ]--
r 63             if(min.compareTo(p) > 0) max = p;
--[ 2022.11.15.10.21.08.636.0 ]--
r 63             if(m.compareTo(p) > 0) max = p;
--[ 2022.11.15.10.21.08.708.0 ]--
r 63             if(ma.compareTo(p) > 0) max = p;
--[ 2022.11.15.10.21.08.871.0 ]--
r 63             if(max.compareTo(p) > 0) max = p;
--[ 2022.11.15.10.21.10.626.0 ]--
r 65         return m;
--[ 2022.11.15.10.21.10.699.0 ]--
r 65         return ma;
--[ 2022.11.15.10.21.10.836.0 ]--
r 65         return max;
--[ 2022.11.15.10.22.38.197.0 ]--
r 51         Point minx = null;
--[ 2022.11.15.10.22.40.589.0 ]--
+ 52         
--[ 2022.11.15.10.22.41.369.0 ]--
r 52         P
--[ 2022.11.15.10.22.41.647.0 ]--
r 52         Po
--[ 2022.11.15.10.22.41.936.0 ]--
r 52         Pon
--[ 2022.11.15.10.22.42.237.0 ]--
r 52         Po
--[ 2022.11.15.10.22.42.354.0 ]--
r 52         P
--[ 2022.11.15.10.22.42.484.0 ]--
r 52         
--[ 2022.11.15.10.22.42.606.0 ]--
- 52
--[ 2022.11.15.10.22.43.172.0 ]--
+ 52         
--[ 2022.11.15.10.22.43.803.0 ]--
r 52         I
--[ 2022.11.15.10.22.44.021.0 ]--
r 52         In
--[ 2022.11.15.10.22.44.126.0 ]--
r 52         Int
--[ 2022.11.15.10.22.44.304.0 ]--
r 52         Int 
--[ 2022.11.15.10.22.44.553.0 ]--
r 52         Int m
--[ 2022.11.15.10.22.44.704.0 ]--
r 52         Int mi
--[ 2022.11.15.10.22.44.861.0 ]--
r 52         Int min
--[ 2022.11.15.10.22.45.054.0 ]--
r 52         Int miny
--[ 2022.11.15.10.22.47.172.0 ]--
r 51         I minx = null;
--[ 2022.11.15.10.22.47.366.0 ]--
r 51         In minx = null;
--[ 2022.11.15.10.22.47.494.0 ]--
r 51         Int minx = null;
--[ 2022.11.15.10.23.30.812.0 ]--
r 51         d minx = null;
--[ 2022.11.15.10.23.30.875.0 ]--
r 51         do minx = null;
--[ 2022.11.15.10.23.30.956.0 ]--
r 51         dou minx = null;
--[ 2022.11.15.10.23.31.147.0 ]--
r 51         doub minx = null;
--[ 2022.11.15.10.23.31.217.0 ]--
r 51         doubl minx = null;
--[ 2022.11.15.10.23.31.365.0 ]--
r 51         double minx = null;
--[ 2022.11.15.10.23.32.743.0 ]--
r 52         d miny
--[ 2022.11.15.10.23.32.852.0 ]--
r 52         do miny
--[ 2022.11.15.10.23.32.913.0 ]--
r 52         dou miny
--[ 2022.11.15.10.23.33.128.0 ]--
r 52         doub miny
--[ 2022.11.15.10.23.33.236.0 ]--
r 52         doubl miny
--[ 2022.11.15.10.23.33.332.0 ]--
r 52         double miny
--[ 2022.11.15.10.23.34.721.0 ]--
r 52         double miny 
--[ 2022.11.15.10.23.34.953.0 ]--
r 52         double miny =
--[ 2022.11.15.10.23.35.085.0 ]--
r 52         double miny = 
--[ 2022.11.15.10.23.35.231.0 ]--
r 52         double miny = 0
--[ 2022.11.15.10.23.35.626.0 ]--
r 52         double miny = 0.
--[ 2022.11.15.10.23.36.153.0 ]--
r 52         double miny = 0
--[ 2022.11.15.10.23.36.443.0 ]--
r 52         double miny = 0;
--[ 2022.11.15.10.23.37.904.0 ]--
r 51         double minx = 0;
--[ 2022.11.15.10.23.57.629.0 ]--
r 51         double minx = ;
--[ 2022.11.15.10.23.58.183.0 ]--
r 51         double minx = n;
--[ 2022.11.15.10.23.58.484.0 ]--
r 51         double minx = nu;
--[ 2022.11.15.10.23.58.642.0 ]--
r 51         double minx = nul;
--[ 2022.11.15.10.23.58.757.0 ]--
r 51         double minx = null;
--[ 2022.11.15.10.24.01.674.0 ]--
r 51         double minx = nul;
--[ 2022.11.15.10.24.01.816.0 ]--
r 51         double minx = nu;
--[ 2022.11.15.10.24.01.967.0 ]--
r 51         double minx = n;
--[ 2022.11.15.10.24.02.140.0 ]--
r 51         double minx = ;
--[ 2022.11.15.10.24.02.351.0 ]--
r 51         double minx =;
--[ 2022.11.15.10.24.02.953.0 ]--
r 51         double minx = ;
--[ 2022.11.15.10.24.04.317.0 ]--
r 51         double minx = -;
--[ 2022.11.15.10.24.04.378.0 ]--
r 51         double minx = -1;
--[ 2022.11.15.10.24.05.521.0 ]--
r 52         double miny = ;
--[ 2022.11.15.10.24.05.778.0 ]--
r 52         double miny = -;
--[ 2022.11.15.10.24.05.898.0 ]--
r 52         double miny = -1;
--[ 2022.11.15.10.24.22.766.0 ]--
r 51         double minx = -;
--[ 2022.11.15.10.24.22.876.0 ]--
r 51         double minx = ;
--[ 2022.11.15.10.24.25.313.0 ]--
r 52         double miny = -;
--[ 2022.11.15.10.24.25.419.0 ]--
r 52         double miny = ;
--[ 2022.11.15.10.27.16.489.0 ]--
- 51
- 51
- 51
- 51
- 51
r 51 
--[ 2022.11.15.10.27.17.055.0 ]--
- 51
--[ 2022.11.15.10.27.19.686.0 ]--
- 55
- 55
- 55
- 55
r 55 
--[ 2022.11.15.10.27.20.205.0 ]--
- 55
--[ 2022.11.15.10.27.25.929.0 ]--
+ 14     
--[ 2022.11.15.10.27.29.044.0 ]--
r 14     d
--[ 2022.11.15.10.27.29.245.0 ]--
r 14     do
--[ 2022.11.15.10.27.29.352.0 ]--
r 14     dou
--[ 2022.11.15.10.27.29.483.0 ]--
r 14     doub
--[ 2022.11.15.10.27.29.617.0 ]--
r 14     doubl
--[ 2022.11.15.10.27.29.723.0 ]--
r 14     doubld
--[ 2022.11.15.10.27.30.311.0 ]--
r 14     doubld 
--[ 2022.11.15.10.27.30.616.0 ]--
r 14     doubld
--[ 2022.11.15.10.27.30.714.0 ]--
r 14     doubl
--[ 2022.11.15.10.27.30.808.0 ]--
r 14     double
--[ 2022.11.15.10.27.30.902.0 ]--
r 14     double 
--[ 2022.11.15.10.27.32.675.0 ]--
r 14     double m
--[ 2022.11.15.10.27.32.826.0 ]--
r 14     double mi
--[ 2022.11.15.10.27.32.930.0 ]--
r 14     double min
--[ 2022.11.15.10.27.33.510.0 ]--
r 14     double min;
--[ 2022.11.15.10.27.33.723.0 ]--
+ 15     
--[ 2022.11.15.10.27.35.008.0 ]--
r 15     d
--[ 2022.11.15.10.27.35.064.0 ]--
r 15     do
--[ 2022.11.15.10.27.35.147.0 ]--
r 15     dou
--[ 2022.11.15.10.27.35.356.0 ]--
r 15     doub
--[ 2022.11.15.10.27.35.449.0 ]--
r 15     doubl
--[ 2022.11.15.10.27.35.551.0 ]--
r 15     double
--[ 2022.11.15.10.27.35.704.0 ]--
r 15     double 
--[ 2022.11.15.10.27.35.950.0 ]--
r 15     double m
--[ 2022.11.15.10.27.36.028.0 ]--
r 15     double ma
--[ 2022.11.15.10.27.36.236.0 ]--
r 15     double max
--[ 2022.11.15.10.27.36.679.0 ]--
r 15     double max;
--[ 2022.11.15.10.27.39.673.0 ]--
+ 23         
--[ 2022.11.15.10.27.40.925.0 ]--
r 23         i
--[ 2022.11.15.10.27.41.032.0 ]--
r 23         if
--[ 2022.11.15.10.27.41.795.0 ]--
r 23         if()
--[ 2022.11.15.10.27.42.292.0 ]--
r 23         if(s)
--[ 2022.11.15.10.27.42.391.0 ]--
r 23         if(si)
--[ 2022.11.15.10.27.42.550.0 ]--
r 23         if(siz)
--[ 2022.11.15.10.27.42.682.0 ]--
r 23         if(size)
--[ 2022.11.15.10.27.43.013.0 ]--
r 23         if(siz)
--[ 2022.11.15.10.27.43.116.0 ]--
r 23         if(si)
--[ 2022.11.15.10.27.43.240.0 ]--
r 23         if(s)
--[ 2022.11.15.10.27.43.360.0 ]--
r 23         if()
--[ 2022.11.15.10.27.43.624.0 ]--
r 23         if(r)
--[ 2022.11.15.10.27.43.958.0 ]--
r 23         if(rb)
--[ 2022.11.15.10.27.44.135.0 ]--
r 23         if(rbs)
--[ 2022.11.15.10.27.45.127.0 ]--
r 23         if(rbst)
--[ 2022.11.15.10.27.45.337.0 ]--
r 23         if(rbst.)
--[ 2022.11.15.10.27.45.546.0 ]--
r 23         if(rbst.s)
--[ 2022.11.15.10.27.47.089.0 ]--
r 23         if(rbst.size)
--[ 2022.11.15.10.27.47.098.0 ]--
r 23         if(rbst.size())
--[ 2022.11.15.10.27.47.956.0 ]--
r 23         if(rbst.size() )
--[ 2022.11.15.10.27.48.218.0 ]--
r 23         if(rbst.size() =)
--[ 2022.11.15.10.27.48.323.0 ]--
r 23         if(rbst.size() ==)
--[ 2022.11.15.10.27.48.566.0 ]--
r 23         if(rbst.size() == )
--[ 2022.11.15.10.27.49.098.0 ]--
r 23         if(rbst.size() == 1)
--[ 2022.11.15.10.27.50.892.0 ]--
r 23         if(rbst.size() == 1) 
--[ 2022.11.15.10.27.52.065.0 ]--
r 23         if(rbst.size() == 1) {
--[ 2022.11.15.10.27.52.299.0 ]--
+ 24 
+ 25 }
--[ 2022.11.15.10.27.52.304.0 ]--
r 25         }
--[ 2022.11.15.10.27.52.312.0 ]--
r 24             
--[ 2022.11.15.10.27.53.654.0 ]--
r 24             m
--[ 2022.11.15.10.27.53.793.0 ]--
r 24             mi
--[ 2022.11.15.10.27.53.908.0 ]--
r 24             min
--[ 2022.11.15.10.27.58.610.0 ]--
r 14     double minx;
--[ 2022.11.15.10.28.03.426.0 ]--
+ 14     double minx;
--[ 2022.11.15.10.28.04.909.0 ]--
+ 14     double minx;
--[ 2022.11.15.10.28.07.159.0 ]--
r 15     double min;
--[ 2022.11.15.10.28.07.250.0 ]--
r 15     double miny;
--[ 2022.11.15.10.28.09.239.0 ]--
r 16     double mix;
--[ 2022.11.15.10.28.09.369.0 ]--
r 16     double mx;
--[ 2022.11.15.10.28.09.687.0 ]--
r 16     double max;
--[ 2022.11.15.10.28.09.953.0 ]--
r 16     double maxx;
--[ 2022.11.15.10.28.13.089.0 ]--
r 17     double maxy;
--[ 2022.11.15.10.28.18.681.0 ]--
r 26             minx
--[ 2022.11.15.10.28.25.740.0 ]--
r 26             minx 
--[ 2022.11.15.10.28.25.850.0 ]--
r 26             minx =
--[ 2022.11.15.10.28.25.963.0 ]--
r 26             minx = 
--[ 2022.11.15.10.28.29.045.0 ]--
r 26             minx = p
--[ 2022.11.15.10.28.29.520.0 ]--
r 26             minx = p.
--[ 2022.11.15.10.28.30.520.0 ]--
r 26             minx = p.x
--[ 2022.11.15.10.28.30.526.0 ]--
r 26             minx = p.x()
--[ 2022.11.15.10.28.31.764.0 ]--
r 26             minx = p.x();
--[ 2022.11.15.10.28.32.128.0 ]--
+ 27             
--[ 2022.11.15.10.28.33.280.0 ]--
r 27             m
--[ 2022.11.15.10.28.33.374.0 ]--
r 27             ma
--[ 2022.11.15.10.28.33.596.0 ]--
r 27             max
--[ 2022.11.15.10.28.34.147.0 ]--
r 27             maxx
--[ 2022.11.15.10.28.34.965.0 ]--
r 27             maxx 
--[ 2022.11.15.10.28.35.076.0 ]--
r 27             maxx =
--[ 2022.11.15.10.28.35.195.0 ]--
r 27             maxx = 
--[ 2022.11.15.10.28.35.574.0 ]--
r 27             maxx = p
--[ 2022.11.15.10.28.35.831.0 ]--
r 27             maxx = p.
--[ 2022.11.15.10.28.36.079.0 ]--
r 27             maxx = p.x
--[ 2022.11.15.10.28.36.334.0 ]--
r 27             maxx = p.x()
--[ 2022.11.15.10.28.37.003.0 ]--
r 27             maxx = p.x();
--[ 2022.11.15.10.28.37.218.0 ]--
+ 28             
--[ 2022.11.15.10.28.37.758.0 ]--
+ 28             
--[ 2022.11.15.10.28.39.177.0 ]--
- 28
--[ 2022.11.15.10.28.39.818.0 ]--
+ 28             
--[ 2022.11.15.10.28.42.228.0 ]--
+ 27             
--[ 2022.11.15.10.28.42.713.0 ]--
+ 27             
--[ 2022.11.15.10.28.44.075.0 ]--
r 27             m
--[ 2022.11.15.10.28.45.091.0 ]--
r 27             mi
--[ 2022.11.15.10.28.45.227.0 ]--
r 27             min
--[ 2022.11.15.10.28.45.470.0 ]--
r 27             miny
--[ 2022.11.15.10.28.45.785.0 ]--
r 27             miny 
--[ 2022.11.15.10.28.46.012.0 ]--
r 27             miny =
--[ 2022.11.15.10.28.46.107.0 ]--
r 27             miny = 
--[ 2022.11.15.10.28.46.428.0 ]--
r 27             miny = p
--[ 2022.11.15.10.28.46.644.0 ]--
r 27             miny = p.
--[ 2022.11.15.10.28.46.859.0 ]--
r 27             miny = p.y
--[ 2022.11.15.10.28.47.381.0 ]--
r 27             miny = p.y()
--[ 2022.11.15.10.28.48.017.0 ]--
r 27             miny = p.y();
--[ 2022.11.15.10.28.49.635.0 ]--
r 30             m
--[ 2022.11.15.10.28.49.824.0 ]--
r 30             ma
--[ 2022.11.15.10.28.50.091.0 ]--
r 30             max
--[ 2022.11.15.10.28.50.959.0 ]--
r 30             maxy
--[ 2022.11.15.10.28.51.042.0 ]--
r 30             maxy 
--[ 2022.11.15.10.28.51.455.0 ]--
r 30             maxy =
--[ 2022.11.15.10.28.51.528.0 ]--
r 30             maxy = 
--[ 2022.11.15.10.28.51.733.0 ]--
r 30             maxy = p
--[ 2022.11.15.10.28.52.560.0 ]--
r 30             maxy = p.
--[ 2022.11.15.10.28.52.843.0 ]--
r 30             maxy = p.y
--[ 2022.11.15.10.28.53.127.0 ]--
r 30             maxy = p.y()
--[ 2022.11.15.10.28.54.568.0 ]--
- 31
--[ 2022.11.15.10.28.55.331.0 ]--
r 30             maxy = p.y();
--[ 2022.11.15.10.28.58.033.0 ]--
+ 32         
--[ 2022.11.15.10.28.59.053.0 ]--
r 32         e
--[ 2022.11.15.10.28.59.119.0 ]--
r 32         el
--[ 2022.11.15.10.28.59.229.0 ]--
r 32         els
--[ 2022.11.15.10.28.59.337.0 ]--
r 32         else
--[ 2022.11.15.10.28.59.569.0 ]--
r 32         else 
--[ 2022.11.15.10.29.00.195.0 ]--
r 32         else {
--[ 2022.11.15.10.29.00.437.0 ]--
+ 33 
+ 34 }
--[ 2022.11.15.10.29.00.444.0 ]--
r 34         }
--[ 2022.11.15.10.29.00.454.0 ]--
r 33             
--[ 2022.11.15.10.29.02.486.0 ]--
r 33             i
--[ 2022.11.15.10.29.02.559.0 ]--
r 33             if
--[ 2022.11.15.10.29.05.966.0 ]--
r 33             if()
--[ 2022.11.15.10.29.08.292.0 ]--
r 33             if(m)
--[ 2022.11.15.10.29.08.379.0 ]--
r 33             if(mi)
--[ 2022.11.15.10.29.08.896.0 ]--
r 33             if(min)
--[ 2022.11.15.10.29.09.162.0 ]--
r 33             if(minx)
--[ 2022.11.15.10.29.09.795.0 ]--
r 33             if(min)
--[ 2022.11.15.10.29.10.380.0 ]--
r 33             if(minx)
--[ 2022.11.15.10.29.10.865.0 ]--
r 33             if(minx )
--[ 2022.11.15.10.29.11.228.0 ]--
r 33             if(minx <)
--[ 2022.11.15.10.29.11.586.0 ]--
r 33             if(minx < )
--[ 2022.11.15.10.29.15.554.0 ]--
r 33             if(minx < p)
--[ 2022.11.15.10.29.15.946.0 ]--
r 33             if(minx < p.)
--[ 2022.11.15.10.29.16.304.0 ]--
r 33             if(minx < p.x)
--[ 2022.11.15.10.29.17.162.0 ]--
r 33             if(minx < p.)
--[ 2022.11.15.10.29.17.741.0 ]--
r 33             if(minx < p.x)
--[ 2022.11.15.10.29.18.093.0 ]--
r 33             if(minx < p.x())
--[ 2022.11.15.10.29.21.611.0 ]--
r 33             if(minx  p.x())
--[ 2022.11.15.10.29.21.983.0 ]--
r 33             if(minx > p.x())
--[ 2022.11.15.10.29.27.539.0 ]--
r 33             if(p)
--[ 2022.11.15.10.29.28.732.0 ]--
r 33             if(p.)
--[ 2022.11.15.10.29.28.953.0 ]--
r 33             if(p.y)
--[ 2022.11.15.10.29.29.384.0 ]--
r 33             if(p.)
--[ 2022.11.15.10.29.29.460.0 ]--
r 33             if(p.x)
--[ 2022.11.15.10.29.30.856.0 ]--
r 33             if(p.x())
--[ 2022.11.15.10.29.31.483.0 ]--
r 33             if(p.x() )
--[ 2022.11.15.10.29.31.665.0 ]--
r 33             if(p.x() <)
--[ 2022.11.15.10.29.31.954.0 ]--
r 33             if(p.x() < )
--[ 2022.11.15.10.29.32.327.0 ]--
r 33             if(p.x() < m)
--[ 2022.11.15.10.29.32.508.0 ]--
r 33             if(p.x() < mi)
--[ 2022.11.15.10.29.32.673.0 ]--
r 33             if(p.x() < min)
--[ 2022.11.15.10.29.32.827.0 ]--
r 33             if(p.x() < minx)
--[ 2022.11.15.10.29.34.442.0 ]--
r 33             if(p.x() < minx) 
--[ 2022.11.15.10.29.34.980.0 ]--
r 33             if(p.x() < minx) n
--[ 2022.11.15.10.29.35.177.0 ]--
r 33             if(p.x() < minx) ni
--[ 2022.11.15.10.29.35.321.0 ]--
r 33             if(p.x() < minx) nin
--[ 2022.11.15.10.29.36.030.0 ]--
r 33             if(p.x() < minx) ni
--[ 2022.11.15.10.29.36.145.0 ]--
r 33             if(p.x() < minx) n
--[ 2022.11.15.10.29.36.233.0 ]--
r 33             if(p.x() < minx) 
--[ 2022.11.15.10.29.36.514.0 ]--
r 33             if(p.x() < minx) m
--[ 2022.11.15.10.29.36.634.0 ]--
r 33             if(p.x() < minx) mi
--[ 2022.11.15.10.29.36.803.0 ]--
r 33             if(p.x() < minx) min
--[ 2022.11.15.10.29.36.996.0 ]--
r 33             if(p.x() < minx) minx
--[ 2022.11.15.10.29.37.641.0 ]--
r 33             if(p.x() < minx) minx 
--[ 2022.11.15.10.29.37.822.0 ]--
r 33             if(p.x() < minx) minx =
--[ 2022.11.15.10.29.37.923.0 ]--
r 33             if(p.x() < minx) minx = 
--[ 2022.11.15.10.29.38.253.0 ]--
r 33             if(p.x() < minx) minx = p
--[ 2022.11.15.10.29.38.557.0 ]--
r 33             if(p.x() < minx) minx = p.
--[ 2022.11.15.10.29.40.002.0 ]--
r 33             if(p.x() < minx) minx = p.x
--[ 2022.11.15.10.29.40.299.0 ]--
r 33             if(p.x() < minx) minx = p.x()
--[ 2022.11.15.10.29.40.885.0 ]--
r 33             if(p.x() < minx) minx = p.x();
--[ 2022.11.15.10.29.44.611.0 ]--
+ 34 
--[ 2022.11.15.10.29.45.813.0 ]--
+ 33             if(p.x() < minx) minx = p.x();
--[ 2022.11.15.10.29.46.334.0 ]--
+ 33             if(p.x() < minx) minx = p.x();
--[ 2022.11.15.10.29.46.719.0 ]--
+ 33             if(p.x() < minx) minx = p.x();
--[ 2022.11.15.10.29.47.845.0 ]--
- 37
--[ 2022.11.15.10.29.50.267.0 ]--
r 34             if(p.x() < minx) min = p.x();
--[ 2022.11.15.10.29.50.291.0 ]--
r 34             if(p.x() < minx) miny = p.x();
--[ 2022.11.15.10.29.51.630.0 ]--
r 34             if(p.x() < minx) miny = p.();
--[ 2022.11.15.10.29.51.661.0 ]--
r 34             if(p.x() < minx) miny = p.y();
--[ 2022.11.15.10.29.53.195.0 ]--
r 34             if(p.x() < min) miny = p.y();
--[ 2022.11.15.10.29.53.228.0 ]--
r 34             if(p.x() < miny) miny = p.y();
--[ 2022.11.15.10.29.54.756.0 ]--
r 34             if(p.() < miny) miny = p.y();
--[ 2022.11.15.10.29.54.791.0 ]--
r 34             if(p.y() < miny) miny = p.y();
--[ 2022.11.15.10.29.56.270.0 ]--
+ 35             
--[ 2022.11.15.10.30.00.357.0 ]--
r 36             if(p.x()  minx) minx = p.x();
--[ 2022.11.15.10.30.00.829.0 ]--
r 36             if(p.x() > minx) minx = p.x();
--[ 2022.11.15.10.30.02.903.0 ]--
r 36             if(p.x() > mix) minx = p.x();
--[ 2022.11.15.10.30.03.006.0 ]--
r 36             if(p.x() > mx) minx = p.x();
--[ 2022.11.15.10.30.03.184.0 ]--
r 36             if(p.x() > max) minx = p.x();
--[ 2022.11.15.10.30.03.371.0 ]--
r 36             if(p.x() > maxx) minx = p.x();
--[ 2022.11.15.10.30.04.745.0 ]--
r 36             if(p.x() > maxx) m = p.x();
--[ 2022.11.15.10.30.04.833.0 ]--
r 36             if(p.x() > maxx) ma = p.x();
--[ 2022.11.15.10.30.05.073.0 ]--
r 36             if(p.x() > maxx) max = p.x();
--[ 2022.11.15.10.30.05.261.0 ]--
r 36             if(p.x() > maxx) maxx = p.x();
--[ 2022.11.15.10.30.08.753.0 ]--
r 37             if(p.() < minx) minx = p.x();
--[ 2022.11.15.10.30.09.016.0 ]--
r 37             if(p.y() < minx) minx = p.x();
--[ 2022.11.15.10.30.12.046.0 ]--
r 37             if(p.y() >x) minx = p.x();
--[ 2022.11.15.10.30.12.296.0 ]--
r 37             if(p.y() > x) minx = p.x();
--[ 2022.11.15.10.30.13.212.0 ]--
r 37             if(p.y() > mx) minx = p.x();
--[ 2022.11.15.10.30.13.317.0 ]--
r 37             if(p.y() > mix) minx = p.x();
--[ 2022.11.15.10.30.13.424.0 ]--
r 37             if(p.y() > minx) minx = p.x();
--[ 2022.11.15.10.30.14.555.0 ]--
r 37             if(p.y() > mix) minx = p.x();
--[ 2022.11.15.10.30.14.672.0 ]--
r 37             if(p.y() > mx) minx = p.x();
--[ 2022.11.15.10.30.14.809.0 ]--
r 37             if(p.y() > x) minx = p.x();
--[ 2022.11.15.10.30.15.499.0 ]--
r 37             if(p.y() > ) minx = p.x();
--[ 2022.11.15.10.30.15.769.0 ]--
r 37             if(p.y() > m) minx = p.x();
--[ 2022.11.15.10.30.15.927.0 ]--
r 37             if(p.y() > ma) minx = p.x();
--[ 2022.11.15.10.30.16.157.0 ]--
r 37             if(p.y() > max) minx = p.x();
--[ 2022.11.15.10.30.16.310.0 ]--
r 37             if(p.y() > maxy) minx = p.x();
--[ 2022.11.15.10.30.18.202.0 ]--
r 37             if(p.y() > maxy) m = p.x();
--[ 2022.11.15.10.30.18.294.0 ]--
r 37             if(p.y() > maxy) ma = p.x();
--[ 2022.11.15.10.30.18.412.0 ]--
r 37             if(p.y() > maxy) max = p.x();
--[ 2022.11.15.10.30.18.560.0 ]--
r 37             if(p.y() > maxy) maxy = p.x();
--[ 2022.11.15.10.30.20.383.0 ]--
r 37             if(p.y() > maxy) maxy = p.();
--[ 2022.11.15.10.30.20.481.0 ]--
r 37             if(p.y() > maxy) maxy = p.y();
--[ 2022.11.15.10.30.34.012.0 ]--
r 69         return mi; 
--[ 2022.11.15.10.30.34.151.0 ]--
r 69         return m; 
--[ 2022.11.15.10.30.34.291.0 ]--
r 69         return ; 
--[ 2022.11.15.10.30.36.691.0 ]--
r 73         return ma;
--[ 2022.11.15.10.30.36.808.0 ]--
r 73         return m;
--[ 2022.11.15.10.30.36.920.0 ]--
r 73         return ;
--[ 2022.11.15.10.30.49.696.0 ]--
r 69         return n; 
--[ 2022.11.15.10.30.49.810.0 ]--
r 69         return ne; 
--[ 2022.11.15.10.30.49.906.0 ]--
r 69         return new; 
--[ 2022.11.15.10.30.52.074.0 ]--
r 69         return new Point; 
--[ 2022.11.15.10.30.52.082.0 ]--
r 69         return new Point(); 
--[ 2022.11.15.10.30.54.476.0 ]--
r 69         return new Point(m); 
--[ 2022.11.15.10.30.54.596.0 ]--
r 69         return new Point(mi); 
--[ 2022.11.15.10.30.54.706.0 ]--
r 69         return new Point(min); 
--[ 2022.11.15.10.30.54.997.0 ]--
r 69         return new Point(minx); 
--[ 2022.11.15.10.30.55.402.0 ]--
r 69         return new Point(minx,); 
--[ 2022.11.15.10.30.55.554.0 ]--
r 69         return new Point(minx, ); 
--[ 2022.11.15.10.30.55.812.0 ]--
r 69         return new Point(minx, m); 
--[ 2022.11.15.10.30.55.941.0 ]--
r 69         return new Point(minx, mi); 
--[ 2022.11.15.10.30.56.050.0 ]--
r 69         return new Point(minx, min); 
--[ 2022.11.15.10.30.56.295.0 ]--
r 69         return new Point(minx, miny); 
--[ 2022.11.15.10.30.58.763.0 ]--
r 73         return n;
--[ 2022.11.15.10.30.58.863.0 ]--
r 73         return ne;
--[ 2022.11.15.10.30.58.950.0 ]--
r 73         return new;
--[ 2022.11.15.10.30.59.191.0 ]--
r 73         return new ;
--[ 2022.11.15.10.31.00.065.0 ]--
r 73         return new Point;
--[ 2022.11.15.10.31.00.078.0 ]--
r 73         return new Point();
--[ 2022.11.15.10.31.00.721.0 ]--
r 73         return new Point(m);
--[ 2022.11.15.10.31.00.798.0 ]--
r 73         return new Point(ma);
--[ 2022.11.15.10.31.00.990.0 ]--
r 73         return new Point(max);
--[ 2022.11.15.10.31.01.161.0 ]--
r 73         return new Point(maxx);
--[ 2022.11.15.10.31.01.764.0 ]--
r 73         return new Point(maxx,);
--[ 2022.11.15.10.31.01.864.0 ]--
r 73         return new Point(maxx, );
--[ 2022.11.15.10.31.02.103.0 ]--
r 73         return new Point(maxx, m);
--[ 2022.11.15.10.31.02.172.0 ]--
r 73         return new Point(maxx, ma);
--[ 2022.11.15.10.31.02.357.0 ]--
r 73         return new Point(maxx, max);
--[ 2022.11.15.10.31.02.545.0 ]--
r 73         return new Point(maxx, maxy);
--[ 2022.11.15.10.31.13.925.0 ]--
r 84     public int size() { return ; }
--[ 2022.11.15.10.31.14.252.0 ]--
r 84     public int size() { return r; }
--[ 2022.11.15.10.31.14.455.0 ]--
r 84     public int size() { return rb; }
--[ 2022.11.15.10.31.14.613.0 ]--
r 84     public int size() { return rbs; }
--[ 2022.11.15.10.31.14.778.0 ]--
r 84     public int size() { return rbst; }
--[ 2022.11.15.10.31.15.013.0 ]--
r 84     public int size() { return rbst.; }
--[ 2022.11.15.10.31.15.223.0 ]--
r 84     public int size() { return rbst.size; }
--[ 2022.11.15.10.31.15.228.0 ]--
r 84     public int size() { return rbst.size(); }
--[ 2022.11.15.10.31.18.787.0 ]--
r 87     public boolean isEmpty() { return r; }
--[ 2022.11.15.10.31.19.042.0 ]--
r 87     public boolean isEmpty() { return rb; }
--[ 2022.11.15.10.31.19.261.0 ]--
r 87     public boolean isEmpty() { return rbs; }
--[ 2022.11.15.10.31.19.911.0 ]--
r 87     public boolean isEmpty() { return rbst.isEmpty; }
--[ 2022.11.15.10.31.19.923.0 ]--
r 87     public boolean isEmpty() { return rbst;; }
--[ 2022.11.15.10.31.19.929.0 ]--
r 87     public boolean isEmpty() { return rbst.isEmpty; }
--[ 2022.11.15.10.31.19.934.0 ]--
r 87     public boolean isEmpty() { return rbst.isEmpty(); }
--[ 2022.11.15.10.31.24.359.0 ]--
r 28 
r 35 
r 50     public Iterable<Point> points() {
r 67     public Point min() {
r 69         return new Point(minx, miny);
r 71     public Point max() {
--[ 2022.11.15.10.31.25.271.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.15.10.31.39.347.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.15.10.32.24.987.0 ]--
+ 61         
--[ 2022.11.15.10.32.28.665.0 ]--
r 61         n
--[ 2022.11.15.10.32.28.712.0 ]--
r 61         ne
--[ 2022.11.15.10.32.29.078.0 ]--
r 61         nea
--[ 2022.11.15.10.32.29.221.0 ]--
r 61         near
--[ 2022.11.15.10.32.29.610.0 ]--
r 61         neare
--[ 2022.11.15.10.32.29.750.0 ]--
r 61         neares
--[ 2022.11.15.10.32.29.937.0 ]--
r 61         nearest
--[ 2022.11.15.10.32.30.698.0 ]--
r 61         nearest()
--[ 2022.11.15.10.32.31.189.0 ]--
r 61         nearest(p)
--[ 2022.11.15.10.32.32.304.0 ]--
r 61         nearest(p);
--[ 2022.11.15.10.32.35.712.0 ]--
r 61         Pnearest(p);
--[ 2022.11.15.10.32.35.939.0 ]--
r 61         Ponearest(p);
--[ 2022.11.15.10.32.36.033.0 ]--
r 61         Poinearest(p);
--[ 2022.11.15.10.32.36.236.0 ]--
r 61         Poinnearest(p);
--[ 2022.11.15.10.32.36.342.0 ]--
r 61         Pointnearest(p);
--[ 2022.11.15.10.32.36.434.0 ]--
r 61         Point nearest(p);
--[ 2022.11.15.10.32.40.721.0 ]--
r 61         Point nnearest(p);
--[ 2022.11.15.10.32.40.738.0 ]--
r 61         Point nenearest(p);
--[ 2022.11.15.10.32.40.909.0 ]--
r 61         Point neanearest(p);
--[ 2022.11.15.10.32.41.063.0 ]--
r 61         Point nearnearest(p);
--[ 2022.11.15.10.32.41.339.0 ]--
r 61         Point nearenearest(p);
--[ 2022.11.15.10.32.41.497.0 ]--
r 61         Point nearesnearest(p);
--[ 2022.11.15.10.32.41.655.0 ]--
r 61         Point nearestnearest(p);
--[ 2022.11.15.10.32.42.753.0 ]--
r 61         Point nearestPnearest(p);
--[ 2022.11.15.10.32.43.474.0 ]--
r 61         Point nearestPonearest(p);
--[ 2022.11.15.10.32.43.734.0 ]--
r 61         Point nearestPoinearest(p);
--[ 2022.11.15.10.32.43.895.0 ]--
r 61         Point nearestPoinnearest(p);
--[ 2022.11.15.10.32.44.022.0 ]--
r 61         Point nearestPointnearest(p);
--[ 2022.11.15.10.32.44.458.0 ]--
r 61         Point nearestPoint nearest(p);
--[ 2022.11.15.10.32.44.955.0 ]--
r 61         Point nearestPoint =nearest(p);
--[ 2022.11.15.10.32.45.035.0 ]--
r 61         Point nearestPoint = nearest(p);
--[ 2022.11.15.10.32.56.252.0 ]--
r 62         return n;
--[ 2022.11.15.10.32.56.321.0 ]--
r 62         return ne;
--[ 2022.11.15.10.32.56.514.0 ]--
r 62         return nea;
--[ 2022.11.15.10.32.56.617.0 ]--
r 62         return near;
--[ 2022.11.15.10.32.56.960.0 ]--
r 62         return nearestPoint;
--[ 2022.11.15.10.32.57.375.0 ]--
r 62         return nearestPoint.;
--[ 2022.11.15.10.33.00.253.0 ]--
r 62         return nearestPoint.v;
--[ 2022.11.15.10.33.01.878.0 ]--
r 62         return nearestPoint.val;
--[ 2022.11.15.10.33.01.889.0 ]--
r 62         return nearestPoint;
--[ 2022.11.15.10.33.01.938.0 ]--
r 62         return nearestPoint1;
--[ 2022.11.15.10.33.01.945.0 ]--
r 62         lombok.val nearestPoint1 = nearestPoint;return nearestPoint1;
--[ 2022.11.15.10.33.01.958.0 ]--
+ 62         lombok.val nearestPoint1 = nearestPoint;
r 63         return nearestPoint1;
--[ 2022.11.15.10.33.01.964.0 ]--
r 63         return nearestPoint;
--[ 2022.11.15.10.33.01.996.0 ]--
r 62           = nearestPoint;
r 63         return ;
--[ 2022.11.15.10.33.02.001.0 ]--
r 62         lombok.val  = nearestPoint;
--[ 2022.11.15.10.33.02.016.0 ]--
r 62         lombok.val nearestPoint1 = nearestPoint;
--[ 2022.11.15.10.33.02.018.0 ]--
r 63         return nearestPoint1;
--[ 2022.11.15.10.33.06.071.0 ]--
- 62
--[ 2022.11.15.10.33.07.775.0 ]--
r 62         return nearestPoint;
--[ 2022.11.15.10.33.31.777.0 ]--
r 62         return nearestPoint.;
--[ 2022.11.15.10.33.31.944.0 ]--
r 62         return nearestPoint.g;
--[ 2022.11.15.10.33.36.003.0 ]--
r 62         return nearestPoint.;
--[ 2022.11.15.10.33.36.125.0 ]--
r 62         return nearestPoint;
--[ 2022.11.15.10.33.39.462.0 ]--
r 62         return rnearestPoint;
--[ 2022.11.15.10.33.39.652.0 ]--
r 62         return rbnearestPoint;
--[ 2022.11.15.10.33.39.842.0 ]--
r 62         return rbsnearestPoint;
--[ 2022.11.15.10.33.40.012.0 ]--
r 62         return rbstnearestPoint;
--[ 2022.11.15.10.33.40.272.0 ]--
r 62         return rbst.nearestPoint;
--[ 2022.11.15.10.33.40.899.0 ]--
r 62         return rbst.gnearestPoint;
--[ 2022.11.15.10.33.41.175.0 ]--
r 62         return rbst.genearestPoint;
--[ 2022.11.15.10.33.41.372.0 ]--
r 62         return rbst.getnearestPoint;
--[ 2022.11.15.10.33.42.005.0 ]--
r 62         return rbst.get(nearestPoint;
--[ 2022.11.15.10.33.44.006.0 ]--
r 62         return rbst.get(nearestPoint);
--[ 2022.11.15.10.34.23.261.0 ]--
+ 79         
--[ 2022.11.15.10.34.30.746.0 ]--
r 79         I
--[ 2022.11.15.10.34.31.033.0 ]--
r 79         It
--[ 2022.11.15.10.34.31.180.0 ]--
r 79         Ite
--[ 2022.11.15.10.34.31.262.0 ]--
r 79         Iter
--[ 2022.11.15.10.34.32.503.0 ]--
r 79         Iterable
--[ 2022.11.15.10.34.33.605.0 ]--
r 79         Iterable<>
--[ 2022.11.15.10.34.34.242.0 ]--
r 79         Iterable<P>
--[ 2022.11.15.10.34.34.683.0 ]--
r 79         Iterable<Po>
--[ 2022.11.15.10.34.34.817.0 ]--
r 79         Iterable<Poi>
--[ 2022.11.15.10.34.35.046.0 ]--
r 79         Iterable<Poin>
--[ 2022.11.15.10.34.35.158.0 ]--
r 79         Iterable<Point>
--[ 2022.11.15.10.34.36.093.0 ]--
r 79         Iterable<Point> 
--[ 2022.11.15.10.34.38.141.0 ]--
r 79         Iterable<Point> p
--[ 2022.11.15.10.34.38.225.0 ]--
r 79         Iterable<Point> pt
--[ 2022.11.15.10.34.39.983.0 ]--
r 79         Iterable<Point> pti
--[ 2022.11.15.10.34.40.016.0 ]--
r 79         Iterable<Point> ptit
--[ 2022.11.15.10.34.41.164.0 ]--
r 79         Iterable<Point> ptit 
--[ 2022.11.15.10.34.41.722.0 ]--
r 79         Iterable<Point> ptit =
--[ 2022.11.15.10.34.41.808.0 ]--
r 79         Iterable<Point> ptit = 
--[ 2022.11.15.10.34.42.369.0 ]--
r 79         Iterable<Point> ptit = n
--[ 2022.11.15.10.34.42.424.0 ]--
r 79         Iterable<Point> ptit = ne
--[ 2022.11.15.10.34.42.521.0 ]--
r 79         Iterable<Point> ptit = new
--[ 2022.11.15.10.34.42.654.0 ]--
r 79         Iterable<Point> ptit = new 
--[ 2022.11.15.10.34.43.784.0 ]--
r 79         Iterable<Point> ptit = new Iterable
--[ 2022.11.15.10.34.43.797.0 ]--
r 79         Iterable<Point> ptit = new Iterable<Point>
--[ 2022.11.15.10.34.43.805.0 ]--
r 79         Iterable<Point> ptit = new Iterable<Point>() {}
--[ 2022.11.15.10.34.43.814.0 ]--
+ 79         Iterable<Point> ptit = new Iterable<Point>() {
r 80         }
--[ 2022.11.15.10.34.43.865.0 ]--
+ 80         @Override
+ 81             public Iterator<Point> iterator() {
+ 82                 return null;
r 83             }}
--[ 2022.11.15.10.34.43.878.0 ]--
r 80             @Override
+ 83             }
r 84         }
--[ 2022.11.15.10.35.45.682.0 ]--
- 80
- 80
- 80
r 80 
--[ 2022.11.15.10.35.46.687.0 ]--
- 80
--[ 2022.11.15.10.35.48.050.0 ]--
r 80         
--[ 2022.11.15.10.35.48.813.0 ]--
- 80
--[ 2022.11.15.10.35.53.595.0 ]--
r 79         Iterable<Point> ptit = new Iterable<>() {
--[ 2022.11.15.10.36.28.543.0 ]--
- 79
--[ 2022.11.15.11.28.46.487.0 ]--
:/src/PSBruteForce.java
r 8 // red-black trees
+ 12 
+ 13     RedBlackBST<Point, Value> rbst;
+ 14     double minx;
+ 15     double miny;
+ 16     double maxx;
+ 17     double maxy;
+ 18     public PSBruteForce() {
+ 19         rbst = new RedBlackBST<>();
r 20     }
+ 24         rbst.put(p,v);
+ 25         if(rbst.size() == 1) {
+ 26             minx = p.x();
+ 27             miny = p.y();
+ 28 
+ 29             maxx = p.x();
+ 30             maxy = p.y();
+ 31         }
+ 32         else {
+ 33             if(p.x() < minx) minx = p.x();
+ 34             if(p.y() < miny) miny = p.y();
+ 35 
+ 36             if(p.x() > maxx) maxx = p.x();
+ 37             if(p.y() > maxy) maxy = p.y();
+ 38         }
r 42         return rbst.get(p);
r 46         return rbst.contains(p);
r 51         return rbst.keys();
+ 56         Point currentNear = null;
+ 57         double nearDist = 0;
+ 58         int idx = 0;
+ 59         Iterable<Point> iter = points();
+ 60         for( Point i : iter ) {
+ 61             if(i != p ) {
+ 62                 double distance = p.dist(i);
+ 63                 if(idx == 0 || distance < nearDist) {
+ 64                     nearDist = distance;
+ 65                     currentNear = i;
+ 66                 }
+ 67             }
+ 68             idx++;
+ 69         }
r 70         return currentNear;
+ 75         Point nearestPoint = nearest(p);
r 76         return rbst.get(nearestPoint);
+ 82     public Point min() {
+ 83         //for each iterable loop, remember the min
+ 84         return new Point(minx, miny);
+ 85     }
+ 86     public Point max() {
+ 87         //same as min, but with max
+ 88         return new Point(maxx, maxy);
r 89     }
r 90 
+ 94         MaxPQ<PointDist> ptpq = new MaxPQ<>(k, PointDist::compareTo);
+ 95 
+ 96         Iterable<Point> iter = points();
+ 97         for( Point i : iter ) {
+ 98             if (i != p) {
+ 99                 PointDist distance = new PointDist(p, p.dist(i));
+ 100                 ptpq.insert(distance);
+ 101                 while (ptpq.size()>k) ptpq.delMax();
+ 102 
+ 103             }
+ 104 
+ 105         }
+ 106         Stack<Point> ptstack = new Stack<>();
+ 107         for(int idx=0; idx<k; idx++) {
+ 108             ptstack.push(ptpq.delMax().p());
+ 109         }
r 110         return ptstack;
r 116     public int size() { return rbst.size(); }
r 119     public boolean isEmpty() { return rbst.isEmpty(); }
--[ 2022.11.15.11.28.46.732.0 ]--
:/src/PSKDTree.java
+ 17 
r 26     public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for inserting
+ 29 
r 34         return null; //search through the tree instead of returning null
r 38         return false; //searching again for p in the bst
r 47     public Iterable<Point> points() { return null; } //account for deletions?
--[ 2022.11.15.11.29.08.261.0 ]--
UpdateTree (AD): 24 0
+ /out/production/P05_KDTrees/.donotlog
+ /out/production/P05_KDTrees/algs4.jar
+ /out/production/P05_KDTrees/stdlib.jar
+ /out/production/P05_KDTrees/input1M.txt
+ /out/production/P05_KDTrees/Mouse.class
+ /out/production/P05_KDTrees/Point.class
+ /out/production/P05_KDTrees/input100K.txt
+ /out/production/P05_KDTrees/Point$1.class
+ /out/production/P05_KDTrees/Point$2.class
+ /out/production/P05_KDTrees/Point$3.class
+ /out/production/P05_KDTrees/Point$4.class
+ /out/production/P05_KDTrees/burgerking.csv
+ /out/production/P05_KDTrees/KeyPress.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/Partition.class
+ /out/production/P05_KDTrees/PointDist.class
+ /out/production/P05_KDTrees/Visualizer.class
+ /out/production/P05_KDTrees/PointSearch.class
+ /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class
+ /out/production/P05_KDTrees/FastFoodVisualizer.class
+ /out/production/P05_KDTrees/Partition$Direction.class
+ /out/production/P05_KDTrees/NearestNeighborVisualizer.class
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22__11_28_AM__Default_.xml

--[ 2022.11.15.11.29.08.262.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.15.11.30.34.532.0 ]--
UpdateTree (AD): 8 0
+ /.git/objects/21/5f9d8b463f594d7a29686b9e9be2c095a4e415
+ /.git/objects/2e/d4fe70b4e088ec2c3ac33ca08f741ed2d35a97
+ /.git/objects/6e/10e3d8976dabc74255b1ddce2024336f50d7e2
+ /.git/objects/9a/e8d0c18cb848aa651381c33a3fa44eddc40bcb
+ /.git/objects/b7/710fca979cfd5216bf2633dd1dfa8161d9f45f
+ /.git/objects/d4/85126c43a458d604c41191c3cd216e30972972
+ /.git/objects/ee/909fb82334c194c06fd779181ba31079f10d42
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22,_11_28_AM_[Default]/shelved.patch

--[ 2022.11.15.11.30.34.535.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.15.11.30.50.425.0 ]--
:/src/NearestNeighborVisualizer.java
r 18         return new PSBrut<>();
--[ 2022.11.15.11.30.50.643.0 ]--
r 18         return new PSBrute<>();
--[ 2022.11.15.11.30.51.762.0 ]--
r 18         return new PSBruteFo<>();
--[ 2022.11.15.11.30.51.924.0 ]--
r 18         return new PSBruteFor<>();
--[ 2022.11.15.11.30.52.247.0 ]--
r 18         return new PSBruteForc<>();
--[ 2022.11.15.11.30.52.462.0 ]--
r 18         return new PSBruteForce<>();
--[ 2022.11.15.11.30.56.494.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2022.11.15.20.38.16.942.0 ]--
:/src/PSBruteForce.java
r 94         MaxPQ<PointDist> ptpq = new MaxPQ<>();
r 98 
r 99                 PointDist distance = new PointDist(i, p.dist(i));
- 102
- 102
- 102
r 104         for(PointDist pd : ptpq) {
r 105             ptstack.push(pd.p());
--[ 2022.11.15.20.38.17.391.0 ]--
:/src/PSKDTree.java
r 25     // add the given Point to kD-tree -- here is 2D (x and y)
r 27         if (v == null) { return; } // can't do anything with a null value
r 28 
+ 30         count++;
--[ 2022.11.15.20.38.34.102.0 ]--
UpdateTree (AD): 8 0
+ /.git/objects/2d/684a62c75f8da8fc231206420108d204cbe252
+ /.git/objects/67/a3cbc10acb52f757cbd15ab1a2acaef561cf5d
+ /.git/objects/75/63d3f1a349009df7dbf21fee30194eead50ca0
+ /.git/objects/ce/2de51fa2f6dd8ca45683eb75ba132137da5a20
+ /.git/objects/d6/6b5e816c127d864df03b0dd33db812fa463679
+ /.git/objects/e9/ce331a35ca02c33b0678d762c13fe57fe4a67a
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22,_8_38_PM_[Default]/shelved.patch
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22__8_38_PM__Default_.xml

--[ 2022.11.15.20.38.34.255.0 ]--
DisposeComponent
--[ 2022.11.16.13.13.05.618.0 ]--
NewLogger: P05_KDTrees
Version: 1.5
--[ 2022.11.16.13.13.05.908.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.git/info/exclude
/.git/logs/refs/heads/main
/.git/logs/refs/remotes/origin/main
/.git/logs/HEAD
/.git/refs/heads/main
/.git/refs/remotes/origin/main
/.git/hooks/update.sample
/.git/hooks/pre-push.sample
/.git/hooks/commit-msg.sample
/.git/hooks/pre-commit.sample
/.git/hooks/pre-rebase.sample
/.git/hooks/post-update.sample
/.git/hooks/pre-receive.sample
/.git/hooks/applypatch-msg.sample
/.git/hooks/pre-applypatch.sample
/.git/hooks/pre-merge-commit.sample
/.git/hooks/push-to-checkout.sample
/.git/hooks/fsmonitor-watchman.sample
/.git/hooks/prepare-commit-msg.sample
/.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
/.git/objects/05/054a55af449d7a3d22569a0d9278837d3116b7
/.git/objects/05/aa0754159021ad4bb196249ebed23fcaee0f05
/.git/objects/0d/90a95e4569ab236f012c54a903f79e23f7e45d
/.git/objects/0f/05624ad8de377d4bdf3ec1558d477af125661c
/.git/objects/11/6f5b50e2bd7e5a645224f577c702fc62092122
/.git/objects/1a/49d62b998226393c172907eef021434d19be9a
/.git/objects/1f/b9dc988a5179e983b847d789447e3c5fa79e57
/.git/objects/21/5f9d8b463f594d7a29686b9e9be2c095a4e415
/.git/objects/26/3963a64f2a64659282fd9cbe561dd7a5e4a676
/.git/objects/2b/5f9208bfadbbc9019b47a713b74462b9cd2613
/.git/objects/2d/684a62c75f8da8fc231206420108d204cbe252
/.git/objects/2e/d4fe70b4e088ec2c3ac33ca08f741ed2d35a97
/.git/objects/30/6f36bddc52f2e08ccf8a41536340870eb1829c
/.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
/.git/objects/39/5d98ffb25a1aa9df31eb7f0e6c2af2e28bc31d
/.git/objects/3c/91061820fd12503e015c3c19cec90b78494358
/.git/objects/43/34e267d8776aabbeb38713c0a502fa328ceb68
/.git/objects/49/554703073ae63a7122c05b80a894ac3ff48370
/.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
/.git/objects/54/0fd2392eaf74abc751e9970668bf235e56f803
/.git/objects/5c/98b428844d9f7d529e2b6fb918d15bf072f3df
/.git/objects/65/427e6010f1b59257bc8ac509401e7eeb2698d4
/.git/objects/67/a3cbc10acb52f757cbd15ab1a2acaef561cf5d
/.git/objects/68/2820a134168b0d23787b376165bef89b511f00
/.git/objects/6e/10e3d8976dabc74255b1ddce2024336f50d7e2
/.git/objects/6e/e6bdaf464e0f4adb373587a385e0875ebf8ba6
/.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
/.git/objects/75/63d3f1a349009df7dbf21fee30194eead50ca0
/.git/objects/7d/61ee6e1564fdc3e562582a8ca1c55185fd2b09
/.git/objects/80/8df08d052527e9a626a08c732fb0fb470708c8
/.git/objects/86/5b56d35df1dcfcbf5196eeddcef674c03a3a93
/.git/objects/8b/e37e197c873cbcd2952f364d9e3a447bc4e692
/.git/objects/8c/333a97e7dbd1f8d32d947ad097e8e247f9f041
/.git/objects/8d/e804238c33c653fe535bd162aabed440497ec7
/.git/objects/91/4c3a82a059ff11e1e2248c3ee1ce32a78bc63a
/.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
/.git/objects/9a/8c6aff1f8871e01cacec32f40b40f4107494d2
/.git/objects/9a/e8d0c18cb848aa651381c33a3fa44eddc40bcb
/.git/objects/9c/780ff1eacdac600ca19795de4e5f1220a1bf3e
/.git/objects/aa/90a9d65e85ba8dedaeee57dbca845093794f15
/.git/objects/aa/d3f0402094e10cd99e06ba2a544a57396b1919
/.git/objects/ae/39a65a74d4111e721807c06e27bd6754992fbb
/.git/objects/b4/a758f2f8c8a18b851825e056e555c5620ae676
/.git/objects/b6/90d19ac158bfa6e1ae11cef101f0d1a7434bd9
/.git/objects/b7/710fca979cfd5216bf2633dd1dfa8161d9f45f
/.git/objects/c2/828bc31a68ae45ce1922d19323206b232cbda4
/.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
/.git/objects/c7/ed19fcb2ed6617a23bd3e9a2efaa966bed42da
/.git/objects/ca/22da9b6c126b0744cfde03b32ebdff29cb41ab
/.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
/.git/objects/ce/2de51fa2f6dd8ca45683eb75ba132137da5a20
/.git/objects/d2/e73db08c8563911c081a8651a77f67c4b48b43
/.git/objects/d4/85126c43a458d604c41191c3cd216e30972972
/.git/objects/d6/6b5e816c127d864df03b0dd33db812fa463679
/.git/objects/de/c87ed246fc3ca006dddb4db1972a0e1d67919e
/.git/objects/e2/3a8b692a016f63a83e1997a2326d3be18d8d1e
/.git/objects/e5/f5f06b6f0fb91e529051f1cb6651cc60ce2f48
/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
/.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
/.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
/.git/objects/e9/ce331a35ca02c33b0678d762c13fe57fe4a67a
/.git/objects/ee/909fb82334c194c06fd779181ba31079f10d42
/.git/objects/ef/89a8450022222b69a62814d66e3f6c8ecb5a60
/.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
/.git/objects/f6/cca8a6084310f182dc287fadbb82c5ebcfffe8
/.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
/.git/HEAD
/.git/index
/.git/config
/.git/ORIG_HEAD
/.git/FETCH_HEAD
/.git/description
/.git/COMMIT_EDITMSG
/.log/history.log
/.idea/shelf/Uncommitted_changes_before_Update_at_11_11_22,_1_29_PM_[Default]/shelved.patch
/.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22,_8_38_PM_[Default]/shelved.patch
/.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22,_11_28_AM_[Default]/shelved.patch
/.idea/shelf/Uncommitted_changes_before_Update_at_11_11_22__1_29_PM__Default_.xml
/.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22__8_38_PM__Default_.xml
/.idea/shelf/Uncommitted_changes_before_Update_at_11_15_22__11_28_AM__Default_.xml
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2022.11.16.13.13.05.911.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2022.11.16.13.13.05.911.1 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2022.11.16.13.13.05.911.2 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2022.11.16.13.13.05.912.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSBruteForce<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2022.11.16.13.13.05.913.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Point(Point p) {
        this.x = p.x;
        this.y = p.y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns a new point that has values added to components
    public Point add(Point p) {
        return add(p.x, p.y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    public boolean isInBounds(Point min, Point max) {
        return isInBounds(min.x, min.y, max.x, max.y);
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2022.11.16.13.13.05.913.1 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSKDTree<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2022.11.16.13.13.05.915.0 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2022.11.16.13.13.05.916.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2022.11.16.13.13.05.916.1 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */

// red-black trees

public class PSBruteForce<Value> implements PointSearch<Value> {
    // constructor makes empty collection

    RedBlackBST<Point, Value> rbst;
    double minx;
    double miny;
    double maxx;
    double maxy;
    public PSBruteForce() {
        rbst = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbst.put(p,v);
        if(rbst.size() == 1) {
            minx = p.x();
            miny = p.y();

            maxx = p.x();
            maxy = p.y();
        }
        else {
            if(p.x() < minx) minx = p.x();
            if(p.y() < miny) miny = p.y();

            if(p.x() > maxx) maxx = p.x();
            if(p.y() > maxy) maxy = p.y();
        }
    }

    public Value get(Point p) {
        return rbst.get(p);
    }

    public boolean contains(Point p) {
        return rbst.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbst.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        Point currentNear = null;
        double nearDist = 0;
        int idx = 0;
        Iterable<Point> iter = points();
        for( Point i : iter ) {
            if(i != p ) {
                double distance = p.dist(i);
                if(idx == 0 || distance < nearDist) {
                    nearDist = distance;
                    currentNear = i;
                }
            }
            idx++;
        }
        return currentNear;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        Point nearestPoint = nearest(p);
        return rbst.get(nearestPoint);
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        //for each iterable loop, remember the min
        return new Point(minx, miny);
    }
    public Point max() {
        //same as min, but with max
        return new Point(maxx, maxy);
    }


    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        MaxPQ<PointDist> ptpq = new MaxPQ<>();

        Iterable<Point> iter = points();
        for( Point i : iter ) {

                PointDist distance = new PointDist(i, p.dist(i));
                ptpq.insert(distance);
                while (ptpq.size()>k) ptpq.delMax();
        }
        Stack<Point> ptstack = new Stack<>();
        for(PointDist pd : ptpq) {
            ptstack.push(pd.p());
        }
        return ptstack;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbst.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() { return rbst.isEmpty(); }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2022.11.16.13.13.05.917.0 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }
    BST<Point, Value> kdt;
    int count=0;

    Point minimum;
    Point maximum;
    // constructor makes empty kD-tree
    public PSKDTree() {
        kdt = new BST<Point, Value>();
    }

    // add the given Point to kD-tree -- here is 2D (x and y)
    public void put(Point p, Value v) {  //change?? remember to alternate x and y coords for inserting
        if (v == null) { return; } // can't do anything with a null value


        count++;
    }

    public Value get(Point p) {
        if(isEmpty()) return null;
        return null; //search through the tree instead of returning null
    }

    public boolean contains(Point p) {
        return false; //searching again for p in the bst
    }

    public Value getNearest(Point p) {
        if(isEmpty()) return null;
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; } //account for deletions?

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() {
        if(isEmpty()) return null;
        return null;
    }
    public Point max() {
        if(isEmpty()) return null;
        return null;
    }

    // return the number of Points in kD-tree
    public int size() { return count; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return count==0; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2022.11.16.13.13.05.919.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2022.11.16.13.13.05.920.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.16.13.13.05.920.1 ]--
InitFile: /.cos265


--[ 2022.11.16.13.14.49.545.0 ]--
:/src/PSKDTree.java
+ 20     
--[ 2022.11.16.13.14.51.092.0 ]--
r 20     Popi
--[ 2022.11.16.13.14.51.783.0 ]--
r 20     Pop
--[ 2022.11.16.13.14.52.036.0 ]--
r 20     Po
--[ 2022.11.16.13.14.52.431.0 ]--
r 20     Poi
--[ 2022.11.16.13.14.52.657.0 ]--
r 20     Poin
--[ 2022.11.16.13.14.52.901.0 ]--
r 20     Point
--[ 2022.11.16.13.14.53.293.0 ]--
r 20     Point 
--[ 2022.11.16.13.14.53.833.0 ]--
r 20     Point ro
--[ 2022.11.16.13.14.54.053.0 ]--
r 20     Point root
--[ 2022.11.16.13.14.54.135.0 ]--
r 20     Point root;
--[ 2022.11.16.13.14.54.640.0 ]--
r 20     Point root; 
--[ 2022.11.16.13.14.56.693.0 ]--
r 20     Point root;
--[ 2022.11.16.13.14.56.888.0 ]--
r 20     Point root
--[ 2022.11.16.13.14.57.401.0 ]--
r 20     Point root=
--[ 2022.11.16.13.14.57.595.0 ]--
r 20     Point root=n
--[ 2022.11.16.13.14.57.848.0 ]--
r 20     Point root=nu
--[ 2022.11.16.13.14.58.037.0 ]--
r 20     Point root=nul
--[ 2022.11.16.13.14.58.172.0 ]--
r 20     Point root=null
--[ 2022.11.16.13.14.58.348.0 ]--
r 20     Point root=null;
--[ 2022.11.16.13.15.06.343.0 ]--
r 29     
--[ 2022.11.16.13.15.06.669.0 ]--
r 29         
--[ 2022.11.16.13.15.14.555.0 ]--
r 29         i
--[ 2022.11.16.13.15.14.824.0 ]--
r 29         if
--[ 2022.11.16.13.15.15.069.0 ]--
r 29         if()
--[ 2022.11.16.13.15.15.534.0 ]--
r 29         if(r)
--[ 2022.11.16.13.15.15.566.0 ]--
r 29         if(ro)
--[ 2022.11.16.13.15.15.731.0 ]--
r 29         if(roo)
--[ 2022.11.16.13.15.15.816.0 ]--
r 29         if(root)
--[ 2022.11.16.13.15.16.475.0 ]--
r 29         if(root=)
--[ 2022.11.16.13.15.16.630.0 ]--
r 29         if(root==)
--[ 2022.11.16.13.15.16.890.0 ]--
r 29         if(root==n)
--[ 2022.11.16.13.15.17.075.0 ]--
r 29         if(root==nu)
--[ 2022.11.16.13.15.17.246.0 ]--
r 29         if(root==nul)
--[ 2022.11.16.13.15.17.406.0 ]--
r 29         if(root==null)
--[ 2022.11.16.13.15.18.276.0 ]--
r 29         if(root==null) 
--[ 2022.11.16.13.15.22.741.0 ]--
r 29         if(root==null) ro
--[ 2022.11.16.13.15.22.922.0 ]--
r 29         if(root==null) roo
--[ 2022.11.16.13.15.23.050.0 ]--
r 29         if(root==null) root
--[ 2022.11.16.13.15.23.446.0 ]--
r 29         if(root==null) root=
--[ 2022.11.16.13.15.24.676.0 ]--
r 29         if(root==null) root=p
--[ 2022.11.16.13.15.25.518.0 ]--
r 29         if(root==null) root=p;
--[ 2022.11.16.13.15.35.120.0 ]--
r 30     
--[ 2022.11.16.13.15.35.289.0 ]--
r 30         
--[ 2022.11.16.13.17.33.375.0 ]--
r 20     N root=null;
--[ 2022.11.16.13.17.33.512.0 ]--
r 20     No root=null;
--[ 2022.11.16.13.17.33.684.0 ]--
r 20     Nod root=null;
--[ 2022.11.16.13.17.33.813.0 ]--
r 20     Node root=null;
--[ 2022.11.16.13.17.36.594.0 ]--
r 29         if(root==null) r
--[ 2022.11.16.13.17.36.749.0 ]--
r 29         if(root==null) 
--[ 2022.11.16.13.17.36.834.0 ]--
r 29         if(root==null)
--[ 2022.11.16.13.17.38.277.0 ]--
r 29         if(root==null) 
--[ 2022.11.16.13.17.39.529.0 ]--
+ 29         
--[ 2022.11.16.13.17.57.393.0 ]--
r 29         No
--[ 2022.11.16.13.17.57.662.0 ]--
r 29         Nod
--[ 2022.11.16.13.17.57.764.0 ]--
r 29         Node
--[ 2022.11.16.13.17.58.457.0 ]--
r 29         Node 
--[ 2022.11.16.13.18.00.002.0 ]--
r 29         Node x
--[ 2022.11.16.13.18.01.393.0 ]--
r 29         Node x 
--[ 2022.11.16.13.18.01.677.0 ]--
r 29         Node x =
--[ 2022.11.16.13.18.01.824.0 ]--
r 29         Node x = 
--[ 2022.11.16.13.18.01.992.0 ]--
r 29         Node x = n
--[ 2022.11.16.13.18.02.102.0 ]--
r 29         Node x = ne
--[ 2022.11.16.13.18.02.199.0 ]--
r 29         Node x = new
--[ 2022.11.16.13.18.02.396.0 ]--
r 29         Node x = new 
--[ 2022.11.16.13.18.02.528.0 ]--
r 29         Node x = new N
--[ 2022.11.16.13.18.02.682.0 ]--
r 29         Node x = new No
--[ 2022.11.16.13.18.02.791.0 ]--
r 29         Node x = new Nod
--[ 2022.11.16.13.18.02.931.0 ]--
r 29         Node x = new Node
--[ 2022.11.16.13.18.03.115.0 ]--
r 29         Node x = new Node;
--[ 2022.11.16.13.18.05.424.0 ]--
+ 30         
--[ 2022.11.16.13.18.18.171.0 ]--
r 29         Node x = new Node();
--[ 2022.11.16.13.18.22.987.0 ]--
r 30         x
--[ 2022.11.16.13.18.23.185.0 ]--
r 30         x.
--[ 2022.11.16.13.18.26.239.0 ]--
r 30         x.p
--[ 2022.11.16.13.18.28.057.0 ]--
r 30         x.p=
--[ 2022.11.16.13.18.29.173.0 ]--
r 30         x.p=p;
--[ 2022.11.16.13.18.29.471.0 ]--
+ 31         
--[ 2022.11.16.13.18.30.611.0 ]--
r 31         x
--[ 2022.11.16.13.18.30.798.0 ]--
r 31         x.
--[ 2022.11.16.13.18.31.023.0 ]--
r 31         x.v
--[ 2022.11.16.13.18.31.897.0 ]--
r 31         x.v=
--[ 2022.11.16.13.18.31.963.0 ]--
r 31         x.v=v
--[ 2022.11.16.13.18.32.416.0 ]--
r 31         x.v=v;
--[ 2022.11.16.13.18.36.765.0 ]--
+ 32         
--[ 2022.11.16.13.18.50.395.0 ]--
- 32
--[ 2022.11.16.13.18.51.803.0 ]--
r 32         if(root==null) {
--[ 2022.11.16.13.18.51.885.0 ]--
r 32         if(root==null) {}
--[ 2022.11.16.13.18.52.527.0 ]--
+ 32         if(root==null) {
r 33         }
--[ 2022.11.16.13.18.52.599.0 ]--
+ 33             
--[ 2022.11.16.13.18.52.693.0 ]--
+ 33             
--[ 2022.11.16.13.18.53.265.0 ]--
- 33
--[ 2022.11.16.13.19.00.251.0 ]--
r 33             x
--[ 2022.11.16.13.19.00.675.0 ]--
r 33             x.
--[ 2022.11.16.13.19.03.778.0 ]--
r 33             x.le
--[ 2022.11.16.13.19.03.903.0 ]--
r 33             x.lef
--[ 2022.11.16.13.19.04.118.0 ]--
r 33             x.left
--[ 2022.11.16.13.19.04.472.0 ]--
r 33             x.left=
--[ 2022.11.16.13.19.04.702.0 ]--
r 33             x.left=n
--[ 2022.11.16.13.19.04.985.0 ]--
r 33             x.left=nu
--[ 2022.11.16.13.19.05.582.0 ]--
r 33             x.left=nul
--[ 2022.11.16.13.19.05.798.0 ]--
r 33             x.left=null
--[ 2022.11.16.13.19.06.949.0 ]--
r 33             x.left=null;
--[ 2022.11.16.13.19.07.126.0 ]--
+ 34             
--[ 2022.11.16.13.19.07.880.0 ]--
r 34             x
--[ 2022.11.16.13.19.08.115.0 ]--
r 34             x.
--[ 2022.11.16.13.19.08.306.0 ]--
r 34             x.r
--[ 2022.11.16.13.19.08.337.0 ]--
r 34             x.ri
--[ 2022.11.16.13.19.08.441.0 ]--
r 34             x.rig
--[ 2022.11.16.13.19.08.487.0 ]--
r 34             x.righ
--[ 2022.11.16.13.19.08.637.0 ]--
r 34             x.right
--[ 2022.11.16.13.19.09.083.0 ]--
r 34             x.right=
--[ 2022.11.16.13.19.09.501.0 ]--
r 34             x.right=n
--[ 2022.11.16.13.19.09.722.0 ]--
r 34             x.right=nu
--[ 2022.11.16.13.19.09.959.0 ]--
r 34             x.right=nul
--[ 2022.11.16.13.19.10.118.0 ]--
r 34             x.right=null
--[ 2022.11.16.13.19.10.259.0 ]--
r 34             x.right=null;
--[ 2022.11.16.13.19.10.474.0 ]--
+ 35             
--[ 2022.11.16.13.19.11.128.0 ]--
r 35             x
--[ 2022.11.16.13.19.11.340.0 ]--
r 35             x.
--[ 2022.11.16.13.19.13.436.0 ]--
r 35             x.d
--[ 2022.11.16.13.19.14.055.0 ]--
r 35             x.di
--[ 2022.11.16.13.19.16.130.0 ]--
r 35             x.dir
--[ 2022.11.16.13.19.16.157.0 ]--
r 35             x.dire
--[ 2022.11.16.13.19.16.594.0 ]--
r 35             x.dir
--[ 2022.11.16.13.19.19.988.0 ]--
r 35             x.dir=
--[ 2022.11.16.13.19.22.498.0 ]--
r 35             x.dir=L
--[ 2022.11.16.13.19.22.794.0 ]--
r 35             x.dir=Le
--[ 2022.11.16.13.19.23.564.0 ]--
r 35             x.dir=L
--[ 2022.11.16.13.19.24.230.0 ]--
r 35             x.dir=LE
--[ 2022.11.16.13.19.25.780.0 ]--
r 35             x.dir=
--[ 2022.11.16.13.19.26.283.0 ]--
r 35             x.dir=D
--[ 2022.11.16.13.19.26.532.0 ]--
r 35             x.dir=Do
--[ 2022.11.16.13.19.26.663.0 ]--
r 35             x.dir=Dow
--[ 2022.11.16.13.19.26.831.0 ]--
r 35             x.dir=Down
--[ 2022.11.16.13.19.28.232.0 ]--
r 35             x.dir=Downu
--[ 2022.11.16.13.19.28.296.0 ]--
r 35             x.dir=Downup
--[ 2022.11.16.13.19.30.407.0 ]--
r 35             x.dir=Downup;
--[ 2022.11.16.13.19.30.756.0 ]--
r 35             x.dir=Downup; 
--[ 2022.11.16.13.19.34.422.0 ]--
r 35             x.dir=DO; 
--[ 2022.11.16.13.19.34.491.0 ]--
r 35             x.dir=DOW; 
--[ 2022.11.16.13.19.34.707.0 ]--
r 35             x.dir=DOWN; 
--[ 2022.11.16.13.19.34.963.0 ]--
r 35             x.dir=DOWNU; 
--[ 2022.11.16.13.19.35.086.0 ]--
r 35             x.dir=DOWNUP; 
--[ 2022.11.16.13.19.36.523.0 ]--
r 35             x.dir=Partition.Direction.DOWNUP; 
--[ 2022.11.16.13.19.36.549.0 ]--
r 35             x.dir=DOWNUP; 
--[ 2022.11.16.13.19.36.559.0 ]--
r 35             x.dir=.DOWNUP; 
--[ 2022.11.16.13.19.36.568.0 ]--
r 35             x.dir=Direction.DOWNUP; 
--[ 2022.11.16.13.19.36.617.0 ]--
r 35             x.dir=Partition.Direction.DOWNUP; 
--[ 2022.11.16.13.19.36.699.0 ]--
r 35             x.dir= Partition.Direction.DOWNUP; 
--[ 2022.11.16.13.19.43.423.0 ]--
+ 36             
--[ 2022.11.16.13.19.43.643.0 ]--
r 36             r
--[ 2022.11.16.13.19.43.742.0 ]--
r 36             ro
--[ 2022.11.16.13.19.43.817.0 ]--
r 36             roo
--[ 2022.11.16.13.19.44.415.0 ]--
r 36             root
--[ 2022.11.16.13.19.44.585.0 ]--
r 36             root=
--[ 2022.11.16.13.19.45.117.0 ]--
r 36             root=x
--[ 2022.11.16.13.19.45.211.0 ]--
r 36             root=x;
--[ 2022.11.16.13.22.50.232.0 ]--
+ 37             
--[ 2022.11.16.13.24.06.260.0 ]--
r 35             x.dir= Partition.Direction.DOWNUP;
r 37 
r 39 
--[ 2022.11.16.13.26.46.692.0 ]--
- 37
--[ 2022.11.16.13.26.47.895.0 ]--
- 38
--[ 2022.11.16.13.26.49.673.0 ]--
+ 40     
--[ 2022.11.16.13.26.51.927.0 ]--
r 40     p
--[ 2022.11.16.13.26.51.982.0 ]--
r 40     pr
--[ 2022.11.16.13.26.52.108.0 ]--
r 40     pri
--[ 2022.11.16.13.26.52.632.0 ]--
r 40     pr
--[ 2022.11.16.13.26.52.784.0 ]--
r 40     p
--[ 2022.11.16.13.26.52.972.0 ]--
r 40     
--[ 2022.11.16.13.26.53.196.0 ]--
+ 40     
--[ 2022.11.16.13.26.53.406.0 ]--
r 41     p
--[ 2022.11.16.13.26.53.587.0 ]--
r 41     pr
--[ 2022.11.16.13.26.53.733.0 ]--
r 41     pri
--[ 2022.11.16.13.26.53.873.0 ]--
r 41     priv
--[ 2022.11.16.13.26.54.174.0 ]--
r 41     priva
--[ 2022.11.16.13.26.54.471.0 ]--
r 41     privat
--[ 2022.11.16.13.26.54.781.0 ]--
r 41     private
--[ 2022.11.16.13.26.55.164.0 ]--
r 41     private 
--[ 2022.11.16.13.26.56.218.0 ]--
r 41     private N
--[ 2022.11.16.13.26.56.403.0 ]--
r 41     private No
--[ 2022.11.16.13.26.56.626.0 ]--
r 41     private Nod
--[ 2022.11.16.13.26.56.846.0 ]--
r 41     private Node
--[ 2022.11.16.13.26.58.636.0 ]--
r 41     private Node 
--[ 2022.11.16.13.26.58.669.0 ]--
r 41     private Node p
--[ 2022.11.16.13.26.58.874.0 ]--
r 41     private Node pu
--[ 2022.11.16.13.26.59.020.0 ]--
r 41     private Node put
--[ 2022.11.16.13.27.00.042.0 ]--
r 41     private Node put()
--[ 2022.11.16.13.27.06.785.0 ]--
r 41     private Node put(N)
--[ 2022.11.16.13.27.06.922.0 ]--
r 41     private Node put(No)
--[ 2022.11.16.13.27.07.043.0 ]--
r 41     private Node put(Nod)
--[ 2022.11.16.13.27.07.328.0 ]--
r 41     private Node put(Node)
--[ 2022.11.16.13.27.08.146.0 ]--
r 41     private Node put(Node )
--[ 2022.11.16.13.27.08.479.0 ]--
r 41     private Node put(Node x)
--[ 2022.11.16.13.27.08.777.0 ]--
r 41     private Node put(Node )
--[ 2022.11.16.13.27.08.879.0 ]--
r 41     private Node put(Node r)
--[ 2022.11.16.13.27.09.177.0 ]--
r 41     private Node put(Node ro)
--[ 2022.11.16.13.27.09.879.0 ]--
r 41     private Node put(Node r)
--[ 2022.11.16.13.27.09.986.0 ]--
r 41     private Node put(Node )
--[ 2022.11.16.13.27.10.471.0 ]--
r 41     private Node put(Node x)
--[ 2022.11.16.13.27.10.602.0 ]--
r 41     private Node put(Node x,)
--[ 2022.11.16.13.27.10.753.0 ]--
r 41     private Node put(Node x, )
--[ 2022.11.16.13.27.14.291.0 ]--
r 41     private Node put(Node x, {})
--[ 2022.11.16.13.27.14.470.0 ]--
r 41     private Node put(Node x, {p})
--[ 2022.11.16.13.27.14.634.0 ]--
r 41     private Node put(Node x, {pi})
--[ 2022.11.16.13.27.14.999.0 ]--
r 41     private Node put(Node x, {p})
--[ 2022.11.16.13.27.15.131.0 ]--
r 41     private Node put(Node x, {})
--[ 2022.11.16.13.27.15.274.0 ]--
r 41     private Node put(Node x, )
--[ 2022.11.16.13.27.15.598.0 ]--
r 41     private Node put(Node x, P)
--[ 2022.11.16.13.27.15.848.0 ]--
r 41     private Node put(Node x, Po)
--[ 2022.11.16.13.27.15.916.0 ]--
r 41     private Node put(Node x, Poi)
--[ 2022.11.16.13.27.16.069.0 ]--
r 41     private Node put(Node x, Poin)
--[ 2022.11.16.13.27.16.195.0 ]--
r 41     private Node put(Node x, Point)
--[ 2022.11.16.13.27.16.293.0 ]--
r 41     private Node put(Node x, Point )
--[ 2022.11.16.13.27.16.361.0 ]--
r 41     private Node put(Node x, Point p)
--[ 2022.11.16.13.27.16.708.0 ]--
r 41     private Node put(Node x, Point p,)
--[ 2022.11.16.13.27.17.733.0 ]--
r 41     private Node put(Node x, Point p, )
--[ 2022.11.16.13.27.18.250.0 ]--
r 41     private Node put(Node x, Point p, V)
--[ 2022.11.16.13.27.18.405.0 ]--
r 41     private Node put(Node x, Point p, Va)
--[ 2022.11.16.13.27.18.511.0 ]--
r 41     private Node put(Node x, Point p, Val)
--[ 2022.11.16.13.27.18.630.0 ]--
r 41     private Node put(Node x, Point p, Valu)
--[ 2022.11.16.13.27.18.782.0 ]--
r 41     private Node put(Node x, Point p, Value)
--[ 2022.11.16.13.27.19.294.0 ]--
r 41     private Node put(Node x, Point p, Value )
--[ 2022.11.16.13.27.19.375.0 ]--
r 41     private Node put(Node x, Point p, Value v)
--[ 2022.11.16.13.27.21.971.0 ]--
r 41     private Node put(Node x, Point p, Value v) 
--[ 2022.11.16.13.27.22.350.0 ]--
r 41     private Node put(Node x, Point p, Value v) {}
--[ 2022.11.16.13.27.23.044.0 ]--
+ 42     
--[ 2022.11.16.13.27.25.111.0 ]--
+ 41     private Node put(Node x, Point p, Value v) {
r 42     }
--[ 2022.11.16.13.27.25.274.0 ]--
+ 42         
--[ 2022.11.16.13.27.27.731.0 ]--
- 45
--[ 2022.11.16.13.27.28.717.0 ]--
r 43         }
--[ 2022.11.16.13.27.29.485.0 ]--
r 43     }
--[ 2022.11.16.13.27.30.969.0 ]--
r 42             
--[ 2022.11.16.13.27.33.382.0 ]--
+ 38         
--[ 2022.11.16.13.27.36.675.0 ]--
r 38         p
--[ 2022.11.16.13.27.36.740.0 ]--
r 38         pu
--[ 2022.11.16.13.27.36.910.0 ]--
r 38         put
--[ 2022.11.16.13.27.37.193.0 ]--
r 38         put()
--[ 2022.11.16.13.27.38.107.0 ]--
r 38         put(x)
--[ 2022.11.16.13.27.40.026.0 ]--
r 38         put()
--[ 2022.11.16.13.27.40.125.0 ]--
r 38         put
--[ 2022.11.16.13.27.40.267.0 ]--
r 38         pu
--[ 2022.11.16.13.27.40.422.0 ]--
r 38         p
--[ 2022.11.16.13.27.40.588.0 ]--
r 38         
--[ 2022.11.16.13.27.40.863.0 ]--
r 38         e
--[ 2022.11.16.13.27.40.987.0 ]--
r 38         el
--[ 2022.11.16.13.27.41.128.0 ]--
r 38         els
--[ 2022.11.16.13.27.41.257.0 ]--
r 38         else
--[ 2022.11.16.13.27.41.809.0 ]--
r 38         else()
--[ 2022.11.16.13.27.41.922.0 ]--
r 38         else()_
--[ 2022.11.16.13.27.43.005.0 ]--
r 38         else(
--[ 2022.11.16.13.27.43.751.0 ]--
r 38         else
--[ 2022.11.16.13.27.44.469.0 ]--
r 38         else 
--[ 2022.11.16.13.27.45.510.0 ]--
r 38         else p
--[ 2022.11.16.13.27.45.752.0 ]--
r 38         else pu
--[ 2022.11.16.13.27.46.133.0 ]--
r 38         else put
--[ 2022.11.16.13.27.46.519.0 ]--
r 38         else put()
--[ 2022.11.16.13.28.05.477.0 ]--
r 38         else put(r)
--[ 2022.11.16.13.28.05.613.0 ]--
r 38         else put(ro)
--[ 2022.11.16.13.28.05.711.0 ]--
r 38         else put(roo)
--[ 2022.11.16.13.28.05.867.0 ]--
r 38         else put(root)
--[ 2022.11.16.13.28.06.006.0 ]--
r 38         else put(root.)
--[ 2022.11.16.13.28.06.794.0 ]--
r 38         else put(root)
--[ 2022.11.16.13.28.06.933.0 ]--
r 38         else put(root,)
--[ 2022.11.16.13.28.07.565.0 ]--
r 38         else put(root)
--[ 2022.11.16.13.28.08.256.0 ]--
r 38         else put(root,)
--[ 2022.11.16.13.28.08.661.0 ]--
r 38         else put(root, )
--[ 2022.11.16.13.28.08.820.0 ]--
r 38         else put(root,  )
--[ 2022.11.16.13.28.08.954.0 ]--
r 38         else put(root,  p)
--[ 2022.11.16.13.28.09.311.0 ]--
r 38         else put(root,  )
--[ 2022.11.16.13.28.09.449.0 ]--
r 38         else put(root, )
--[ 2022.11.16.13.28.10.058.0 ]--
r 38         else put(root, p)
--[ 2022.11.16.13.28.10.385.0 ]--
r 38         else put(root, p,)
--[ 2022.11.16.13.28.10.532.0 ]--
r 38         else put(root, p, )
--[ 2022.11.16.13.28.11.094.0 ]--
r 38         else put(root, p, v)
--[ 2022.11.16.13.28.15.789.0 ]--
r 29 //        Node x = new Node();
r 30 //        x.p=p;
r 31 //        x.v=v;
r 32 //        if(root==null) {
r 33 //            x.left=null;
r 34 //            x.right=null;
r 35 //            x.dir= Partition.Direction.DOWNUP;
r 36 //            root=x;
r 37 //        }
--[ 2022.11.16.13.28.18.944.0 ]--
r 32         if(root==null) {
r 33             x.left=null;
r 34             x.right=null;
r 35             x.dir= Partition.Direction.DOWNUP;
r 36             root=x;
r 37         }
--[ 2022.11.16.13.28.22.220.0 ]--
r 29 /        Node x = new Node();
--[ 2022.11.16.13.28.22.310.0 ]--
r 29         Node x = new Node();
--[ 2022.11.16.13.28.27.196.0 ]--
r 29         
--[ 2022.11.16.13.28.27.610.0 ]--
+ 33             
--[ 2022.11.16.13.28.27.816.0 ]--
r 33             Node x = new Node();
--[ 2022.11.16.13.28.30.461.0 ]--
r 30 //       
--[ 2022.11.16.13.28.31.219.0 ]--
+ 34             
--[ 2022.11.16.13.28.31.443.0 ]--
r 34              x.p=p;
--[ 2022.11.16.13.28.31.496.0 ]--
r 34             x.p=p;
--[ 2022.11.16.13.28.33.626.0 ]--
r 31 //        
--[ 2022.11.16.13.28.34.930.0 ]--
+ 35             
--[ 2022.11.16.13.28.35.033.0 ]--
r 35             x.v=v;
--[ 2022.11.16.13.28.36.352.0 ]--
- 30
r 30  
--[ 2022.11.16.13.28.36.509.0 ]--
- 30
--[ 2022.11.16.13.28.38.855.0 ]--
r 39         else put(root, p, v);
--[ 2022.11.16.13.28.45.374.0 ]--
r 44         
--[ 2022.11.16.13.33.13.363.0 ]--
r 29 
r 42 
r 44 
r 46 
--[ 2022.11.16.13.35.32.636.0 ]--
r 44     
--[ 2022.11.16.13.35.32.666.0 ]--
r 44         
--[ 2022.11.16.13.36.02.051.0 ]--
r 44                 if (x == null) return new Node(key, val, 1);
--[ 2022.11.16.13.36.02.163.0 ]--
r 44                 if (x == null) return new BST.Node(key, val, 1);
--[ 2022.11.16.13.36.02.261.0 ]--
r 44         if (x == null) return new BST.Node(key, val, 1);
--[ 2022.11.16.13.36.06.850.0 ]--
r 44         if (x == null) return new BST.Node(key, v, 1);
--[ 2022.11.16.13.36.08.773.0 ]--
r 44         if (x == null) return new BST.Node(k, v, 1);
--[ 2022.11.16.13.36.16.386.0 ]--
r 44         if (x == null) return new BSTNode(k, v, 1);
--[ 2022.11.16.13.36.16.524.0 ]--
r 44         if (x == null) return new BSNode(k, v, 1);
--[ 2022.11.16.13.36.16.656.0 ]--
r 44         if (x == null) return new BNode(k, v, 1);
--[ 2022.11.16.13.36.16.780.0 ]--
r 44         if (x == null) return new Node(k, v, 1);
--[ 2022.11.16.13.36.42.446.0 ]--
r 44         if (x == null) return new Node(, v, 1);
--[ 2022.11.16.13.36.42.987.0 ]--
r 44         if (x == null) return new Node(x, v, 1);
--[ 2022.11.16.13.36.44.681.0 ]--
r 44         if (x == null) return new Node(x, , 1);
--[ 2022.11.16.13.36.45.228.0 ]--
r 44         if (x == null) return new Node(x, k, 1);
--[ 2022.11.16.13.36.48.301.0 ]--
r 44         if (x == null) return new Node(x, , 1);
--[ 2022.11.16.13.36.48.448.0 ]--
r 44         if (x == null) return new Node(x, p, 1);
--[ 2022.11.16.13.36.49.550.0 ]--
r 44         if (x == null) return new Node(x, p, );
--[ 2022.11.16.13.36.49.687.0 ]--
r 44         if (x == null) return new Node(x, p, v);
--[ 2022.11.16.13.37.04.664.0 ]--
+ 15     
--[ 2022.11.16.13.37.20.953.0 ]--
+ 14         
--[ 2022.11.16.13.37.21.377.0 ]--
+ 14         
--[ 2022.11.16.13.37.21.944.0 ]--
r 15         p
--[ 2022.11.16.13.37.22.063.0 ]--
r 15         pu
--[ 2022.11.16.13.37.22.303.0 ]--
r 15         pub
--[ 2022.11.16.13.37.22.382.0 ]--
r 15         publ
--[ 2022.11.16.13.37.22.544.0 ]--
r 15         publi
--[ 2022.11.16.13.37.22.860.0 ]--
r 15         public
--[ 2022.11.16.13.37.22.999.0 ]--
r 15         public 
--[ 2022.11.16.13.37.23.339.0 ]--
r 15         public N
--[ 2022.11.16.13.37.23.529.0 ]--
r 15         public No
--[ 2022.11.16.13.37.23.640.0 ]--
r 15         public Nod
--[ 2022.11.16.13.37.23.829.0 ]--
r 15         public Node
--[ 2022.11.16.13.37.24.296.0 ]--
r 15         public Node()
--[ 2022.11.16.13.37.27.477.0 ]--
r 15         public Node(P)
--[ 2022.11.16.13.37.27.738.0 ]--
r 15         public Node(Po)
--[ 2022.11.16.13.37.27.786.0 ]--
r 15         public Node(Poi)
--[ 2022.11.16.13.37.27.980.0 ]--
r 15         public Node(Poin)
--[ 2022.11.16.13.37.28.093.0 ]--
r 15         public Node(Point)
--[ 2022.11.16.13.37.28.274.0 ]--
r 15         public Node(Point )
--[ 2022.11.16.13.37.28.541.0 ]--
r 15         public Node(Point p)
--[ 2022.11.16.13.37.28.918.0 ]--
r 15         public Node(Point p,)
--[ 2022.11.16.13.37.28.986.0 ]--
r 15         public Node(Point p, )
--[ 2022.11.16.13.37.29.352.0 ]--
r 15         public Node(Point p, V)
--[ 2022.11.16.13.37.29.527.0 ]--
r 15         public Node(Point p, Va)
--[ 2022.11.16.13.37.29.607.0 ]--
r 15         public Node(Point p, Val)
--[ 2022.11.16.13.37.29.768.0 ]--
r 15         public Node(Point p, Valu)
--[ 2022.11.16.13.37.29.881.0 ]--
r 15         public Node(Point p, Value)
--[ 2022.11.16.13.37.30.343.0 ]--
r 15         public Node(Point p, Value )
--[ 2022.11.16.13.37.30.491.0 ]--
r 15         public Node(Point p, Value v)
--[ 2022.11.16.13.37.31.015.0 ]--
r 15         public Node(Point p, Value v,)
--[ 2022.11.16.13.37.31.117.0 ]--
r 15         public Node(Point p, Value v, )
--[ 2022.11.16.13.37.31.773.0 ]--
r 15         public Node(Point p, Value v, N)
--[ 2022.11.16.13.37.32.441.0 ]--
r 15         public Node(Point p, Value v, Node)
--[ 2022.11.16.13.37.32.701.0 ]--
r 15         public Node(Point p, Value v, Node )
--[ 2022.11.16.13.37.32.929.0 ]--
r 15         public Node(Point p, Value v, Node l)
--[ 2022.11.16.13.37.33.250.0 ]--
r 15         public Node(Point p, Value v, Node le)
--[ 2022.11.16.13.37.33.426.0 ]--
r 15         public Node(Point p, Value v, Node lef)
--[ 2022.11.16.13.37.33.641.0 ]--
r 15         public Node(Point p, Value v, Node left)
--[ 2022.11.16.13.37.34.230.0 ]--
r 15         public Node(Point p, Value v, Node left )
--[ 2022.11.16.13.37.34.683.0 ]--
r 15         public Node(Point p, Value v, Node left)
--[ 2022.11.16.13.37.35.000.0 ]--
r 15         public Node(Point p, Value v, Node left,)
--[ 2022.11.16.13.37.35.067.0 ]--
r 15         public Node(Point p, Value v, Node left, )
--[ 2022.11.16.13.37.35.501.0 ]--
r 15         public Node(Point p, Value v, Node left, N)
--[ 2022.11.16.13.37.35.936.0 ]--
r 15         public Node(Point p, Value v, Node left, No)
--[ 2022.11.16.13.37.36.092.0 ]--
r 15         public Node(Point p, Value v, Node left, Nod)
--[ 2022.11.16.13.37.36.249.0 ]--
r 15         public Node(Point p, Value v, Node left, Node)
--[ 2022.11.16.13.37.36.437.0 ]--
r 15         public Node(Point p, Value v, Node left, Node )
--[ 2022.11.16.13.37.36.783.0 ]--
r 15         public Node(Point p, Value v, Node left, Node r)
--[ 2022.11.16.13.37.36.874.0 ]--
r 15         public Node(Point p, Value v, Node left, Node ri)
--[ 2022.11.16.13.37.36.999.0 ]--
r 15         public Node(Point p, Value v, Node left, Node rig)
--[ 2022.11.16.13.37.37.119.0 ]--
r 15         public Node(Point p, Value v, Node left, Node righ)
--[ 2022.11.16.13.37.37.162.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right)
--[ 2022.11.16.13.37.37.577.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right,)
--[ 2022.11.16.13.37.37.637.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, )
--[ 2022.11.16.13.37.38.658.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, P)
--[ 2022.11.16.13.37.38.907.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Pa)
--[ 2022.11.16.13.37.38.938.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Par)
--[ 2022.11.16.13.37.39.156.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Part)
--[ 2022.11.16.13.37.39.277.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Parti)
--[ 2022.11.16.13.37.39.474.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partid)
--[ 2022.11.16.13.37.39.963.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Parti)
--[ 2022.11.16.13.37.40.067.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partit)
--[ 2022.11.16.13.37.40.206.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partiti)
--[ 2022.11.16.13.37.40.375.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partitio)
--[ 2022.11.16.13.37.40.568.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition)
--[ 2022.11.16.13.37.41.472.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.)
--[ 2022.11.16.13.37.42.655.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Dire)
--[ 2022.11.16.13.37.42.775.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direc)
--[ 2022.11.16.13.37.42.992.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direct)
--[ 2022.11.16.13.37.43.081.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Directi)
--[ 2022.11.16.13.37.43.161.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Directio)
--[ 2022.11.16.13.37.43.554.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direction)
--[ 2022.11.16.13.37.43.727.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direction )
--[ 2022.11.16.13.37.43.969.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direction d)
--[ 2022.11.16.13.37.44.083.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direction di)
--[ 2022.11.16.13.37.44.172.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direction dir)
--[ 2022.11.16.13.37.45.674.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direction dir) 
--[ 2022.11.16.13.37.45.822.0 ]--
r 15         public Node(Point p, Value v, Node left, Node right, Partition.Direction dir) {}
--[ 2022.11.16.13.37.46.042.0 ]--
+ 15         public Node(Point p, Value v, Node left, Node right, Partition.Direction dir) {
r 16         }
--[ 2022.11.16.13.37.46.102.0 ]--
+ 16             
--[ 2022.11.16.13.37.47.941.0 ]--
r 16             p
--[ 2022.11.16.13.37.48.191.0 ]--
r 16             p 
--[ 2022.11.16.13.37.48.314.0 ]--
r 16             p =
--[ 2022.11.16.13.37.48.439.0 ]--
r 16             p = 
--[ 2022.11.16.13.37.48.615.0 ]--
r 16             p = p
--[ 2022.11.16.13.37.49.398.0 ]--
r 16             p = p;
--[ 2022.11.16.13.37.52.336.0 ]--
r 15         public Node(Point poi, Value v, Node left, Node right, Partition.Direction dir) {
--[ 2022.11.16.13.37.52.518.0 ]--
r 15         public Node(Point poin, Value v, Node left, Node right, Partition.Direction dir) {
--[ 2022.11.16.13.37.52.618.0 ]--
r 15         public Node(Point point, Value v, Node left, Node right, Partition.Direction dir) {
--[ 2022.11.16.13.37.55.412.0 ]--
r 15         public Node(Point point, Value va, Node left, Node right, Partition.Direction dir) {
--[ 2022.11.16.13.37.55.449.0 ]--
r 15         public Node(Point point, Value val, Node left, Node right, Partition.Direction dir) {
--[ 2022.11.16.13.38.01.498.0 ]--
r 15         public Node(Point point, Value val, Node lef, Node right, Partition.Direction dir) {
--[ 2022.11.16.13.38.01.614.0 ]--
r 15         public Node(Point point, Value val, Node le, Node right, Partition.Direction dir) {
--[ 2022.11.16.13.38.01.745.0 ]--
r 15         public Node(Point point, Value val, Node l, Node right, Partition.Direction dir) {
--[ 2022.11.16.13.38.03.567.0 ]--
r 15         public Node(Point point, Value val, Node l, Node righ, Partition.Direction dir) {
--[ 2022.11.16.13.38.03.698.0 ]--
r 15         public Node(Point point, Value val, Node l, Node rig, Partition.Direction dir) {
--[ 2022.11.16.13.38.03.850.0 ]--
r 15         public Node(Point point, Value val, Node l, Node ri, Partition.Direction dir) {
--[ 2022.11.16.13.38.03.994.0 ]--
r 15         public Node(Point point, Value val, Node l, Node r, Partition.Direction dir) {
--[ 2022.11.16.13.38.05.673.0 ]--
r 15         public Node(Point point, Value val, Node l, Node r, Partition.Direction di) {
--[ 2022.11.16.13.38.05.764.0 ]--
r 15         public Node(Point point, Value val, Node l, Node r, Partition.Direction d) {
--[ 2022.11.16.13.38.08.876.0 ]--
r 15         public Node(Point poit, Value val, Node l, Node r, Partition.Direction d) {
--[ 2022.11.16.13.38.08.924.0 ]--
r 15         public Node(Point pot, Value val, Node l, Node r, Partition.Direction d) {
--[ 2022.11.16.13.38.09.535.0 ]--
r 15         public Node(Point pt, Value val, Node l, Node r, Partition.Direction d) {
--[ 2022.11.16.13.38.11.853.0 ]--
r 16             p = pt;
--[ 2022.11.16.13.38.12.710.0 ]--
+ 17             
--[ 2022.11.16.13.38.14.250.0 ]--
r 17             v
--[ 2022.11.16.13.38.14.578.0 ]--
r 17             v 
--[ 2022.11.16.13.38.14.613.0 ]--
r 17             v =
--[ 2022.11.16.13.38.14.755.0 ]--
r 17             v = 
--[ 2022.11.16.13.38.15.316.0 ]--
r 17             v = v
--[ 2022.11.16.13.38.15.402.0 ]--
r 17             v = va
--[ 2022.11.16.13.38.15.489.0 ]--
r 17             v = val
--[ 2022.11.16.13.38.15.942.0 ]--
+ 18             
--[ 2022.11.16.13.38.16.005.0 ]--
r 18                     
--[ 2022.11.16.13.38.16.597.0 ]--
- 18
--[ 2022.11.16.13.38.17.321.0 ]--
r 17             v = val;
--[ 2022.11.16.13.38.17.563.0 ]--
+ 18             
--[ 2022.11.16.13.38.18.590.0 ]--
r 18             l
--[ 2022.11.16.13.38.19.109.0 ]--
r 18             
--[ 2022.11.16.13.38.19.464.0 ]--
r 18             N
--[ 2022.11.16.13.38.20.228.0 ]--
r 18             
--[ 2022.11.16.13.38.20.508.0 ]--
r 18             l
--[ 2022.11.16.13.38.20.681.0 ]--
r 18             le
--[ 2022.11.16.13.38.20.746.0 ]--
r 18             lef
--[ 2022.11.16.13.38.20.956.0 ]--
r 18             left
--[ 2022.11.16.13.38.21.148.0 ]--
r 18             left 
--[ 2022.11.16.13.38.21.262.0 ]--
r 18             left =
--[ 2022.11.16.13.38.21.386.0 ]--
r 18             left = 
--[ 2022.11.16.13.38.22.423.0 ]--
r 18             left = l
--[ 2022.11.16.13.38.22.722.0 ]--
r 18             left = l;
--[ 2022.11.16.13.38.23.025.0 ]--
+ 19             
--[ 2022.11.16.13.38.23.676.0 ]--
r 19             r
--[ 2022.11.16.13.38.23.744.0 ]--
r 19             ri
--[ 2022.11.16.13.38.23.925.0 ]--
r 19             rig
--[ 2022.11.16.13.38.23.941.0 ]--
r 19             righ
--[ 2022.11.16.13.38.24.120.0 ]--
r 19             right
--[ 2022.11.16.13.38.24.493.0 ]--
r 19             right 
--[ 2022.11.16.13.38.24.625.0 ]--
r 19             right =
--[ 2022.11.16.13.38.24.652.0 ]--
r 19             right = 
--[ 2022.11.16.13.38.24.961.0 ]--
r 19             right = r
--[ 2022.11.16.13.38.25.357.0 ]--
r 19             right = r;
--[ 2022.11.16.13.38.25.636.0 ]--
+ 20             
--[ 2022.11.16.13.38.26.930.0 ]--
r 20             di
--[ 2022.11.16.13.38.27.024.0 ]--
r 20             dir
--[ 2022.11.16.13.38.27.307.0 ]--
r 20             dir 
--[ 2022.11.16.13.38.27.437.0 ]--
r 20             dir =
--[ 2022.11.16.13.38.27.532.0 ]--
r 20             dir = 
--[ 2022.11.16.13.38.27.886.0 ]--
r 20             dir = d
--[ 2022.11.16.13.38.28.179.0 ]--
r 20             dir = d;
--[ 2022.11.16.13.38.40.085.0 ]--
r 53         if (x == null) return new Node(x,p, v);
--[ 2022.11.16.13.38.40.138.0 ]--
r 53         if (x == null) return new Node(xp, v);
--[ 2022.11.16.13.38.40.259.0 ]--
r 53         if (x == null) return new Node(p, v);
--[ 2022.11.16.13.38.42.781.0 ]--
r 53         if (x == null) return new Node(p, v,);
--[ 2022.11.16.13.38.43.011.0 ]--
r 53         if (x == null) return new Node(p, v, );
--[ 2022.11.16.13.38.45.152.0 ]--
r 53         if (x == null) return new Node(p, v, n);
--[ 2022.11.16.13.38.45.376.0 ]--
r 53         if (x == null) return new Node(p, v, nu);
--[ 2022.11.16.13.38.45.582.0 ]--
r 53         if (x == null) return new Node(p, v, nul);
--[ 2022.11.16.13.38.45.723.0 ]--
r 53         if (x == null) return new Node(p, v, null);
--[ 2022.11.16.13.38.45.964.0 ]--
r 53         if (x == null) return new Node(p, v, null,);
--[ 2022.11.16.13.38.46.098.0 ]--
r 53         if (x == null) return new Node(p, v, null, );
--[ 2022.11.16.13.38.47.201.0 ]--
r 53         if (x == null) return new Node(p, v, null, n);
--[ 2022.11.16.13.38.47.337.0 ]--
r 53         if (x == null) return new Node(p, v, null, nu);
--[ 2022.11.16.13.38.47.516.0 ]--
r 53         if (x == null) return new Node(p, v, null, nul);
--[ 2022.11.16.13.38.47.658.0 ]--
r 53         if (x == null) return new Node(p, v, null, null);
--[ 2022.11.16.13.38.47.867.0 ]--
r 53         if (x == null) return new Node(p, v, null, null,);
--[ 2022.11.16.13.38.47.984.0 ]--
r 53         if (x == null) return new Node(p, v, null, null, );
--[ 2022.11.16.13.39.02.776.0 ]--
r 53         if (x == null) {return new Node(p, v, null, null, );
--[ 2022.11.16.13.39.02.995.0 ]--
+ 53         if (x == null) {
+ 54 return new Node(p, v, null, null, );
r 55 }
--[ 2022.11.16.13.39.03.027.0 ]--
r 54             return new Node(p, v, null, null, );
r 55         }
--[ 2022.11.16.13.39.05.809.0 ]--
+ 54             
--[ 2022.11.16.13.39.12.385.0 ]--
r 54             new Node(p, v, null, null, );
--[ 2022.11.16.13.39.16.381.0 ]--
r 54             new Node(p, v, null, null, D);
--[ 2022.11.16.13.39.16.594.0 ]--
r 54             new Node(p, v, null, null, DO);
--[ 2022.11.16.13.39.16.960.0 ]--
r 54             new Node(p, v, null, null, DOW);
--[ 2022.11.16.13.39.17.095.0 ]--
r 54             new Node(p, v, null, null, DOWN);
--[ 2022.11.16.13.39.18.177.0 ]--
r 54             new Node(p, v, null, null, Partition.Direction.DOWNUP);
--[ 2022.11.16.13.39.18.191.0 ]--
r 54             new Node(p, v, null, null, DOWNUP);
--[ 2022.11.16.13.39.18.205.0 ]--
r 54             new Node(p, v, null, null, .DOWNUP);
--[ 2022.11.16.13.39.18.215.0 ]--
r 54             new Node(p, v, null, null, Direction.DOWNUP);
--[ 2022.11.16.13.39.18.228.0 ]--
r 54             new Node(p, v, null, null, Partition.Direction.DOWNUP);
--[ 2022.11.16.13.39.22.387.0 ]--
+ 55             
--[ 2022.11.16.13.39.22.649.0 ]--
+ 55                         new Node(p, v, null, null, Partition.Direction.DOWNUP);
r 56 
--[ 2022.11.16.13.39.22.678.0 ]--
r 55             new Node(p, v, null, null, Partition.Direction.DOWNUP);
--[ 2022.11.16.13.39.24.600.0 ]--
r 55             new Node(p, v, null, null, Partition.Direction.L);
--[ 2022.11.16.13.39.25.603.0 ]--
r 55             new Node(p, v, null, null, Partition.Direction.LEFTRIGHT);
--[ 2022.11.16.13.39.28.154.0 ]--
+ 54             
--[ 2022.11.16.13.39.29.105.0 ]--
r 54             if
--[ 2022.11.16.13.39.50.164.0 ]--
r 15         public Node(Point pt, Value val) {
--[ 2022.11.16.13.39.56.645.0 ]--
- 18
- 18
r 18 
--[ 2022.11.16.13.39.57.225.0 ]--
- 18
--[ 2022.11.16.13.40.38.406.0 ]--
r 52             new Node(p, v\);
--[ 2022.11.16.13.40.39.313.0 ]--
r 52             new Node(p, v);
--[ 2022.11.16.13.40.43.641.0 ]--
r 53 
--[ 2022.11.16.13.40.43.935.0 ]--
- 53
--[ 2022.11.16.13.40.45.857.0 ]--
r 51             
--[ 2022.11.16.13.40.46.080.0 ]--
- 51
--[ 2022.11.16.13.40.46.282.0 ]--
r 50         if (x == null) 
--[ 2022.11.16.13.40.51.751.0 ]--
r 53             return new Node(p, v);
--[ 2022.11.16.13.40.55.800.0 ]--
- 51
- 51
--[ 2022.11.16.13.40.57.907.0 ]--
r 52         
--[ 2022.11.16.13.40.58.253.0 ]--
- 52
--[ 2022.11.16.13.41.03.596.0 ]--
- 50
r 50         if (x == null) return new Node(p, v);
--[ 2022.11.16.13.41.10.479.0 ]--
+ 51         
--[ 2022.11.16.13.41.11.189.0 ]--
r 51         r
--[ 2022.11.16.13.41.11.239.0 ]--
r 51         re
--[ 2022.11.16.13.41.11.502.0 ]--
r 51         reu
--[ 2022.11.16.13.41.11.566.0 ]--
r 51         reut
--[ 2022.11.16.13.41.11.877.0 ]--
r 51         reu
--[ 2022.11.16.13.41.11.996.0 ]--
r 51         re
--[ 2022.11.16.13.41.12.391.0 ]--
r 51         ret
--[ 2022.11.16.13.41.12.463.0 ]--
r 51         retu
--[ 2022.11.16.13.41.12.552.0 ]--
r 51         retur
--[ 2022.11.16.13.41.12.802.0 ]--
r 51         return
--[ 2022.11.16.13.41.13.019.0 ]--
r 51         return 
--[ 2022.11.16.13.41.13.977.0 ]--
r 51         return ;
--[ 2022.11.16.13.41.20.074.0 ]--
+ 51         
--[ 2022.11.16.13.41.35.988.0 ]--
r 51         P
--[ 2022.11.16.13.41.36.221.0 ]--
r 51         Pa
--[ 2022.11.16.13.41.36.613.0 ]--
r 51         P
--[ 2022.11.16.13.41.37.567.0 ]--
r 51         
--[ 2022.11.16.13.41.40.899.0 ]--
r 51         j
--[ 2022.11.16.13.41.41.482.0 ]--
r 51         
--[ 2022.11.16.13.41.41.968.0 ]--
r 51         P
--[ 2022.11.16.13.41.43.345.0 ]--
r 51         Par
--[ 2022.11.16.13.41.43.566.0 ]--
r 51         Part
--[ 2022.11.16.13.41.44.523.0 ]--
r 51         Part.
--[ 2022.11.16.13.41.44.976.0 ]--
r 51         Part
--[ 2022.11.16.13.41.45.012.0 ]--
r 51         Part    
--[ 2022.11.16.13.41.45.565.0 ]--
r 51         Part   
--[ 2022.11.16.13.41.45.697.0 ]--
r 51         Part  
--[ 2022.11.16.13.41.45.937.0 ]--
r 51         Part 
--[ 2022.11.16.13.41.46.914.0 ]--
r 51         Parti
--[ 2022.11.16.13.41.47.764.0 ]--
r 51         Partit
--[ 2022.11.16.13.41.47.841.0 ]--
r 51         Partiti
--[ 2022.11.16.13.41.47.912.0 ]--
r 51         Partitio
--[ 2022.11.16.13.41.48.126.0 ]--
r 51         Partition
--[ 2022.11.16.13.41.48.427.0 ]--
r 51         Partition.
--[ 2022.11.16.13.41.48.642.0 ]--
r 51         Partition.d
--[ 2022.11.16.13.41.51.544.0 ]--
r 51         Partition.
--[ 2022.11.16.13.41.51.900.0 ]--
r 51         Partition.D
--[ 2022.11.16.13.41.52.407.0 ]--
r 51         Partition.Direction
--[ 2022.11.16.13.41.54.378.0 ]--
r 51         Partition.Direction 
--[ 2022.11.16.13.41.58.112.0 ]--
r 51         Partition.Direction p
--[ 2022.11.16.13.41.58.202.0 ]--
r 51         Partition.Direction pa
--[ 2022.11.16.13.41.58.265.0 ]--
r 51         Partition.Direction par
--[ 2022.11.16.13.41.58.535.0 ]--
r 51         Partition.Direction pare
--[ 2022.11.16.13.41.58.803.0 ]--
r 51         Partition.Direction paren
--[ 2022.11.16.13.41.58.908.0 ]--
r 51         Partition.Direction parent
--[ 2022.11.16.13.41.59.470.0 ]--
r 51         Partition.Direction parentD
--[ 2022.11.16.13.41.59.852.0 ]--
r 51         Partition.Direction parentDi
--[ 2022.11.16.13.41.59.886.0 ]--
r 51         Partition.Direction parentDir
--[ 2022.11.16.13.42.01.092.0 ]--
r 51         Partition.Direction parentDir 
--[ 2022.11.16.13.42.01.189.0 ]--
r 51         Partition.Direction parentDir =
--[ 2022.11.16.13.42.01.279.0 ]--
r 51         Partition.Direction parentDir = 
--[ 2022.11.16.13.42.02.907.0 ]--
r 51         Partition.Direction parentDir = x
--[ 2022.11.16.13.42.03.284.0 ]--
r 51         Partition.Direction parentDir = x.
--[ 2022.11.16.13.42.04.102.0 ]--
r 51         Partition.Direction parentDir = x.dir
--[ 2022.11.16.13.42.04.604.0 ]--
r 51         Partition.Direction parentDir = x.dir;
--[ 2022.11.16.13.42.05.948.0 ]--
+ 52         
--[ 2022.11.16.13.42.10.100.0 ]--
r 52         i
--[ 2022.11.16.13.42.10.159.0 ]--
r 52         if
--[ 2022.11.16.13.42.12.684.0 ]--
r 52         if()
--[ 2022.11.16.13.42.13.272.0 ]--
r 52         if(d)
--[ 2022.11.16.13.42.13.356.0 ]--
r 52         if(di)
--[ 2022.11.16.13.42.13.473.0 ]--
r 52         if(dir)
--[ 2022.11.16.13.42.13.637.0 ]--
r 52         if(dir )
--[ 2022.11.16.13.42.13.928.0 ]--
r 52         if(dir =)
--[ 2022.11.16.13.42.14.028.0 ]--
r 52         if(dir ==)
--[ 2022.11.16.13.42.14.109.0 ]--
r 52         if(dir == )
--[ 2022.11.16.13.42.14.687.0 ]--
r 52         if(dir == D)
--[ 2022.11.16.13.42.14.891.0 ]--
r 52         if(dir == DO)
--[ 2022.11.16.13.42.15.076.0 ]--
r 52         if(dir == DOW)
--[ 2022.11.16.13.42.15.266.0 ]--
r 52         if(dir == DOWN)
--[ 2022.11.16.13.42.16.203.0 ]--
r 52         if(dir == DOWNU)
--[ 2022.11.16.13.42.16.275.0 ]--
r 52         if(dir == DOWNUP)
--[ 2022.11.16.13.42.21.681.0 ]--
r 52         if(dir == .DOWNUP)
--[ 2022.11.16.13.42.21.727.0 ]--
r 52         if(dir == Direction.DOWNUP)
--[ 2022.11.16.13.42.21.753.0 ]--
r 52         if(dir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.21.763.0 ]--
r 52         if(dir == Direction.DOWNUP)
--[ 2022.11.16.13.42.21.771.0 ]--
r 52         if(dir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.27.591.0 ]--
r 52         if(pdir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.27.708.0 ]--
r 52         if(padir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.27.762.0 ]--
r 52         if(pardir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.27.926.0 ]--
r 52         if(paredir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.28.072.0 ]--
r 52         if(parendir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.28.196.0 ]--
r 52         if(parentdir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.28.789.0 ]--
r 52         if(parentir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.29.053.0 ]--
r 52         if(parentDir == Partition.Direction.DOWNUP)
--[ 2022.11.16.13.42.30.661.0 ]--
r 52         if(parentDir == Partition.Direction.DOWNUP) 
--[ 2022.11.16.13.42.30.949.0 ]--
r 52         if(parentDir == Partition.Direction.DOWNUP) {
--[ 2022.11.16.13.42.31.151.0 ]--
+ 53 
+ 54 }
--[ 2022.11.16.13.42.31.183.0 ]--
r 54         }
--[ 2022.11.16.13.42.31.211.0 ]--
r 53             
--[ 2022.11.16.13.42.38.203.0 ]--
r 53             i
--[ 2022.11.16.13.42.38.261.0 ]--
r 53             if
--[ 2022.11.16.13.42.39.759.0 ]--
r 53             if()
--[ 2022.11.16.13.42.40.587.0 ]--
r 53             if(x)
--[ 2022.11.16.13.42.42.714.0 ]--
r 53             if(x.)
--[ 2022.11.16.13.42.43.711.0 ]--
r 53             if(x.x)
--[ 2022.11.16.13.42.45.052.0 ]--
r 53             if(x.x())
--[ 2022.11.16.13.42.48.679.0 ]--
r 53             if(x.x()
--[ 2022.11.16.13.42.48.829.0 ]--
r 53             if(x.x)
--[ 2022.11.16.13.42.49.084.0 ]--
r 53             if(x.)
--[ 2022.11.16.13.42.54.772.0 ]--
r 53             if(x.p)
--[ 2022.11.16.13.42.55.114.0 ]--
r 53             if(x.p.)
--[ 2022.11.16.13.42.55.532.0 ]--
r 53             if(x.p.x)
--[ 2022.11.16.13.42.56.063.0 ]--
r 53             if(x.p.x())
--[ 2022.11.16.13.42.58.476.0 ]--
r 53             if(x.p.x() )
--[ 2022.11.16.13.42.59.547.0 ]--
r 53             if(x.p.x() >)
--[ 2022.11.16.13.42.59.726.0 ]--
r 53             if(x.p.x() > )
--[ 2022.11.16.13.43.00.783.0 ]--
r 53             if(x.p.x() > p)
--[ 2022.11.16.13.43.01.144.0 ]--
r 53             if(x.p.x() > p.)
--[ 2022.11.16.13.43.01.536.0 ]--
r 53             if(x.p.x() > p.x)
--[ 2022.11.16.13.43.02.098.0 ]--
r 53             if(x.p.x() > p.x())
--[ 2022.11.16.13.43.05.029.0 ]--
r 53             if(x.p.x() > p.x()) 
--[ 2022.11.16.13.43.05.842.0 ]--
r 53             if(x.p.x() > p.x()) p
--[ 2022.11.16.13.43.05.890.0 ]--
r 53             if(x.p.x() > p.x()) pu
--[ 2022.11.16.13.43.06.045.0 ]--
r 53             if(x.p.x() > p.x()) put
--[ 2022.11.16.13.43.08.038.0 ]--
r 53             if(x.p.x() > p.x()) put()
--[ 2022.11.16.13.43.08.994.0 ]--
r 53             if(x.p.x() > p.x()) put(A)
--[ 2022.11.16.13.43.09.337.0 ]--
r 53             if(x.p.x() > p.x()) put(A.)
--[ 2022.11.16.13.43.13.655.0 ]--
r 53             if(x.p.x() > p.x()) put(A.l)
--[ 2022.11.16.13.43.13.897.0 ]--
r 53             if(x.p.x() > p.x()) put(A.le)
--[ 2022.11.16.13.43.15.526.0 ]--
r 53             if(x.p.x() > p.x()) put(A.lef)
--[ 2022.11.16.13.43.15.708.0 ]--
r 53             if(x.p.x() > p.x()) put(A.left)
--[ 2022.11.16.13.43.17.826.0 ]--
r 53             if(x.p.x() > p.x()) put(.left)
--[ 2022.11.16.13.43.18.733.0 ]--
r 53             if(x.p.x() > p.x()) put(x.left)
--[ 2022.11.16.13.43.20.910.0 ]--
r 53             if(x.p.x() > p.x()) put(x.left,)
--[ 2022.11.16.13.43.20.989.0 ]--
r 53             if(x.p.x() > p.x()) put(x.left, )
--[ 2022.11.16.13.43.21.481.0 ]--
r 53             if(x.p.x() > p.x()) put(x.left, p)
--[ 2022.11.16.13.43.22.097.0 ]--
r 53             if(x.p.x() > p.x()) put(x.left, p, )
--[ 2022.11.16.13.43.22.136.0 ]--
r 53             if(x.p.x() > p.x()) put(x.left, p, v)
--[ 2022.11.16.13.43.25.181.0 ]--
r 53             if(x.p.x() > p.x()) put(x.left, p, v);
--[ 2022.11.16.13.43.28.596.0 ]--
+ 54             
--[ 2022.11.16.13.43.29.111.0 ]--
r 54             e
--[ 2022.11.16.13.43.29.238.0 ]--
r 54             el
--[ 2022.11.16.13.43.29.311.0 ]--
r 54             els
--[ 2022.11.16.13.43.29.421.0 ]--
r 54             else
--[ 2022.11.16.13.43.31.490.0 ]--
r 54             else 
--[ 2022.11.16.13.43.31.976.0 ]--
r 54             else p
--[ 2022.11.16.13.43.32.089.0 ]--
r 54             else pu
--[ 2022.11.16.13.43.32.262.0 ]--
r 54             else put
--[ 2022.11.16.13.43.32.999.0 ]--
r 54             else put()
--[ 2022.11.16.13.43.33.625.0 ]--
r 54             else put(x)
--[ 2022.11.16.13.43.33.855.0 ]--
r 54             else put(x.)
--[ 2022.11.16.13.43.34.079.0 ]--
r 54             else put(x.r)
--[ 2022.11.16.13.43.34.179.0 ]--
r 54             else put(x.ri)
--[ 2022.11.16.13.43.34.298.0 ]--
r 54             else put(x.rig)
--[ 2022.11.16.13.43.34.383.0 ]--
r 54             else put(x.righ)
--[ 2022.11.16.13.43.34.478.0 ]--
r 54             else put(x.right)
--[ 2022.11.16.13.43.35.253.0 ]--
r 54             else put(x.right,)
--[ 2022.11.16.13.43.35.544.0 ]--
r 54             else put(x.right,p)
--[ 2022.11.16.13.43.36.228.0 ]--
r 54             else put(x.right,p,)
--[ 2022.11.16.13.43.36.488.0 ]--
r 54             else put(x.right,p,v)
--[ 2022.11.16.13.43.37.791.0 ]--
r 54             else put(x.right,p,v);
--[ 2022.11.16.13.43.38.168.0 ]--
+ 55             
--[ 2022.11.16.13.43.38.743.0 ]--
- 55
--[ 2022.11.16.13.43.40.246.0 ]--
+ 56         
--[ 2022.11.16.13.43.42.167.0 ]--
r 56         e
--[ 2022.11.16.13.43.42.280.0 ]--
r 56         el
--[ 2022.11.16.13.43.42.601.0 ]--
r 56         els
--[ 2022.11.16.13.43.42.702.0 ]--
r 56         else
--[ 2022.11.16.13.43.43.432.0 ]--
r 56         else 
--[ 2022.11.16.13.43.43.698.0 ]--
r 56         else {
--[ 2022.11.16.13.43.44.052.0 ]--
+ 57 
+ 58 }
--[ 2022.11.16.13.43.44.079.0 ]--
r 58         }
--[ 2022.11.16.13.43.44.091.0 ]--
r 57             
--[ 2022.11.16.13.43.49.075.0 ]--
+ 57             if(x.p.x() > p.x()) put(x.left, p, v);
r 58             else put(x.right,p,v);            
--[ 2022.11.16.13.43.50.981.0 ]--
r 57             if(x.p.() > p.x()) put(x.left, p, v);
--[ 2022.11.16.13.43.51.059.0 ]--
r 57             if(x.p.y() > p.x()) put(x.left, p, v);
--[ 2022.11.16.13.43.53.205.0 ]--
r 57             if(x.p.y() > p.()) put(x.left, p, v);
--[ 2022.11.16.13.43.53.243.0 ]--
r 57             if(x.p.y() > p.y()) put(x.left, p, v);
--[ 2022.11.16.13.44.13.244.0 ]--
r 60         return x;
--[ 2022.11.16.13.47.56.720.0 ]--
r 53             if(x.p.x() > p.x()) xput(x.left, p, v);
--[ 2022.11.16.13.47.56.914.0 ]--
r 53             if(x.p.x() > p.x()) x.put(x.left, p, v);
--[ 2022.11.16.13.47.57.841.0 ]--
r 53             if(x.p.x() > p.x()) x.lput(x.left, p, v);
--[ 2022.11.16.13.47.57.910.0 ]--
r 53             if(x.p.x() > p.x()) x.leput(x.left, p, v);
--[ 2022.11.16.13.47.58.014.0 ]--
r 53             if(x.p.x() > p.x()) x.lefput(x.left, p, v);
--[ 2022.11.16.13.47.58.314.0 ]--
r 53             if(x.p.x() > p.x()) x.leftput(x.left, p, v);
--[ 2022.11.16.13.47.58.633.0 ]--
r 53             if(x.p.x() > p.x()) x.left put(x.left, p, v);
--[ 2022.11.16.13.47.58.742.0 ]--
r 53             if(x.p.x() > p.x()) x.left =put(x.left, p, v);
--[ 2022.11.16.13.47.58.820.0 ]--
r 53             if(x.p.x() > p.x()) x.left = put(x.left, p, v);
--[ 2022.11.16.13.48.02.094.0 ]--
r 54             else xput(x.right,p,v);
--[ 2022.11.16.13.48.02.199.0 ]--
r 54             else x.put(x.right,p,v);
--[ 2022.11.16.13.48.02.416.0 ]--
r 54             else x.rput(x.right,p,v);
--[ 2022.11.16.13.48.02.522.0 ]--
r 54             else x.riput(x.right,p,v);
--[ 2022.11.16.13.48.02.704.0 ]--
r 54             else x.rigput(x.right,p,v);
--[ 2022.11.16.13.48.02.866.0 ]--
r 54             else x.righput(x.right,p,v);
--[ 2022.11.16.13.48.03.081.0 ]--
r 54             else x.rightput(x.right,p,v);
--[ 2022.11.16.13.48.03.633.0 ]--
r 54             else x.right put(x.right,p,v);
--[ 2022.11.16.13.48.03.721.0 ]--
r 54             else x.right =put(x.right,p,v);
--[ 2022.11.16.13.48.03.815.0 ]--
r 54             else x.right = put(x.right,p,v);
--[ 2022.11.16.13.48.06.828.0 ]--
r 57             if(x.p.y() > p.y()) xput(x.left, p, v);
--[ 2022.11.16.13.48.07.014.0 ]--
r 57             if(x.p.y() > p.y()) x.put(x.left, p, v);
--[ 2022.11.16.13.48.07.381.0 ]--
r 57             if(x.p.y() > p.y()) x.lput(x.left, p, v);
--[ 2022.11.16.13.48.07.522.0 ]--
r 57             if(x.p.y() > p.y()) x.leput(x.left, p, v);
--[ 2022.11.16.13.48.07.792.0 ]--
r 57             if(x.p.y() > p.y()) x.lefput(x.left, p, v);
--[ 2022.11.16.13.48.08.060.0 ]--
r 57             if(x.p.y() > p.y()) x.leftput(x.left, p, v);
--[ 2022.11.16.13.48.09.153.0 ]--
r 57             if(x.p.y() > p.y()) x.left = put(x.left, p, v);
--[ 2022.11.16.13.48.11.995.0 ]--
r 58             else xput(x.right,p,v);            
--[ 2022.11.16.13.48.12.157.0 ]--
r 58             else x.put(x.right,p,v);            
--[ 2022.11.16.13.48.12.323.0 ]--
r 58             else x.rput(x.right,p,v);            
--[ 2022.11.16.13.48.12.448.0 ]--
r 58             else x.riput(x.right,p,v);            
--[ 2022.11.16.13.48.12.561.0 ]--
r 58             else x.rigput(x.right,p,v);            
--[ 2022.11.16.13.48.12.639.0 ]--
r 58             else x.righput(x.right,p,v);            
--[ 2022.11.16.13.48.12.738.0 ]--
r 58             else x.rightput(x.right,p,v);            
--[ 2022.11.16.13.48.13.856.0 ]--
r 58             else x.right=put(x.right,p,v);            
--[ 2022.11.16.13.48.14.292.0 ]--
r 58             else x.right= put(x.right,p,v);            
--[ 2022.11.16.13.48.15.794.0 ]--
r 58             else x.right = put(x.right,p,v);            
--[ 2022.11.16.13.49.57.975.0 ]--
r 14 
r 20 
r 58             else x.right = put(x.right,p,v);
