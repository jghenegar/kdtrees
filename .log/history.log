--[ 2022.11.11.13.15.58.079.0 ]--
NewLogger: P05_KDTrees
Version: 1.5
--[ 2022.11.11.13.15.58.793.0 ]--
InitTree:
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2022.11.11.13.15.58.798.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2022.11.11.13.15.58.798.1 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    // constructor makes empty collection
    public PSBruteForce() { }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return 0; }

    // return whether the KDTree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2022.11.11.13.15.58.799.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2022.11.11.13.15.58.800.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Point(Point p) {
        this.x = p.x;
        this.y = p.y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns a new point that has values added to components
    public Point add(Point p) {
        return add(p.x, p.y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    public boolean isInBounds(Point min, Point max) {
        return isInBounds(min.x, min.y, max.x, max.y);
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2022.11.11.13.15.58.833.0 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSKDTree<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2022.11.11.13.15.58.834.0 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2022.11.11.13.15.58.835.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2022.11.11.13.15.58.836.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.11.13.15.58.836.1 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2022.11.11.13.15.58.837.0 ]--
InitFile: /.cos265


--[ 2022.11.11.13.15.58.837.1 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2022.11.11.13.15.58.837.2 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2022.11.11.13.15.58.837.3 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2022.11.11.13.28.27.633.0 ]--
NewLogger: P05_KDTrees
Version: 1.5
--[ 2022.11.11.13.28.27.906.0 ]--
InitTree:
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.git/info/exclude
/.git/logs/refs/heads/main
/.git/logs/refs/remotes/origin/HEAD
/.git/logs/HEAD
/.git/refs/heads/main
/.git/refs/remotes/origin/HEAD
/.git/hooks/update.sample
/.git/hooks/pre-push.sample
/.git/hooks/commit-msg.sample
/.git/hooks/pre-commit.sample
/.git/hooks/pre-rebase.sample
/.git/hooks/post-update.sample
/.git/hooks/pre-receive.sample
/.git/hooks/applypatch-msg.sample
/.git/hooks/pre-applypatch.sample
/.git/hooks/pre-merge-commit.sample
/.git/hooks/push-to-checkout.sample
/.git/hooks/fsmonitor-watchman.sample
/.git/hooks/prepare-commit-msg.sample
/.git/objects/pack/pack-5320b6e6be866c618967d59f12c11bde247dfe82.idx
/.git/objects/pack/pack-5320b6e6be866c618967d59f12c11bde247dfe82.pack
/.git/HEAD
/.git/index
/.git/config
/.git/description
/.git/packed-refs
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/vcs.xml
/.idea/misc.xml
/.idea/.gitignore
/.idea/modules.xml
/.idea/compiler.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/P05_KDTrees.iml

--[ 2022.11.11.13.28.27.907.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2022.11.11.13.28.27.907.1 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSKDTree<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2022.11.11.13.28.27.907.2 ]--
InitFile: /.cos265


--[ 2022.11.11.13.28.27.907.3 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2022.11.11.13.28.27.908.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Point(Point p) {
        this.x = p.x;
        this.y = p.y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns a new point that has values added to components
    public Point add(Point p) {
        return add(p.x, p.y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    public boolean isInBounds(Point min, Point max) {
        return isInBounds(min.x, min.y, max.x, max.y);
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2022.11.11.13.28.27.908.1 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    // constructor makes empty collection
    public PSBruteForce() { }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return 0; }

    // return whether the KDTree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2022.11.11.13.28.27.908.2 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2022.11.11.13.28.27.908.3 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2022.11.11.13.28.27.908.4 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2022.11.11.13.28.27.908.5 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2022.11.11.13.28.27.909.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2022.11.11.13.28.27.909.1 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2022.11.11.13.28.27.909.2 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2022.11.11.13.28.42.015.0 ]--
:/src/PSBruteForce.java
+ 7  
--[ 2022.11.11.13.28.42.081.0 ]--
r 7 
--[ 2022.11.11.13.28.42.123.0 ]--
+ 7 
--[ 2022.11.11.13.28.43.544.0 ]--
+ 7 
--[ 2022.11.11.13.28.56.576.0 ]--
r 8 /
--[ 2022.11.11.13.28.57.099.0 ]--
r 8 /*
--[ 2022.11.11.13.28.58.326.0 ]--
r 8 /
--[ 2022.11.11.13.28.58.714.0 ]--
r 8 //
--[ 2022.11.11.13.28.59.078.0 ]--
r 8 // 
--[ 2022.11.11.13.29.01.020.0 ]--
r 8 // T
--[ 2022.11.11.13.29.01.199.0 ]--
r 8 // Te
--[ 2022.11.11.13.29.01.458.0 ]--
r 8 // Tes
--[ 2022.11.11.13.29.01.665.0 ]--
r 8 // Test
--[ 2022.11.11.13.29.01.756.0 ]--
r 8 // Testi
--[ 2022.11.11.13.29.01.876.0 ]--
r 8 // Testin
--[ 2022.11.11.13.29.01.972.0 ]--
r 8 // Testing
--[ 2022.11.11.13.29.02.066.0 ]--
r 8 // Testing 
--[ 2022.11.11.13.29.06.233.0 ]--
r 8 // Testing G
--[ 2022.11.11.13.29.06.369.0 ]--
r 8 // Testing Gi
--[ 2022.11.11.13.29.06.443.0 ]--
r 8 // Testing Git
--[ 2022.11.11.13.29.07.453.0 ]--
r 8 // Testing Git 
--[ 2022.11.11.13.29.07.646.0 ]--
r 8 // Testing Git -
--[ 2022.11.11.13.29.07.767.0 ]--
r 8 // Testing Git --
--[ 2022.11.11.13.29.08.100.0 ]--
r 8 // Testing Git -- 
--[ 2022.11.11.13.29.08.486.0 ]--
r 8 // Testing Git -- K
--[ 2022.11.11.13.29.08.922.0 ]--
r 8 // Testing Git -- Km
--[ 2022.11.11.13.29.09.096.0 ]--
r 8 // Testing Git -- Kmi
--[ 2022.11.11.13.29.09.251.0 ]--
r 8 // Testing Git -- Kmik
--[ 2022.11.11.13.29.09.520.0 ]--
r 8 // Testing Git -- Kmi
--[ 2022.11.11.13.29.09.647.0 ]--
r 8 // Testing Git -- Km
--[ 2022.11.11.13.29.09.846.0 ]--
r 8 // Testing Git -- K
--[ 2022.11.11.13.29.10.014.0 ]--
r 8 // Testing Git -- 
--[ 2022.11.11.13.29.10.388.0 ]--
r 8 // Testing Git -- k
--[ 2022.11.11.13.29.10.540.0 ]--
r 8 // Testing Git -- km
--[ 2022.11.11.13.29.10.685.0 ]--
r 8 // Testing Git -- kmi
--[ 2022.11.11.13.29.10.853.0 ]--
r 8 // Testing Git -- kmik
--[ 2022.11.11.13.29.10.993.0 ]--
r 8 // Testing Git -- kmike
--[ 2022.11.11.13.29.11.084.0 ]--
r 8 // Testing Git -- kmikel
--[ 2022.11.11.13.29.11.174.0 ]--
r 8 // Testing Git -- kmikels
--[ 2022.11.11.13.29.50.882.0 ]--
:/src/PSBruteForce.java
+ 7 
+ 8 // Testing Git -- kmikels
+ 9 
--[ 2022.11.11.13.29.50.959.0 ]--
UpdateTree (AD): 72 0
+ /.git/info/exclude
+ /.git/logs/refs/heads/main
+ /.git/logs/refs/remotes/origin/main
+ /.git/logs/HEAD
+ /.git/refs/heads/main
+ /.git/refs/remotes/origin/main
+ /.git/hooks/update.sample
+ /.git/hooks/pre-push.sample
+ /.git/hooks/commit-msg.sample
+ /.git/hooks/pre-commit.sample
+ /.git/hooks/pre-rebase.sample
+ /.git/hooks/post-update.sample
+ /.git/hooks/pre-receive.sample
+ /.git/hooks/applypatch-msg.sample
+ /.git/hooks/pre-applypatch.sample
+ /.git/hooks/pre-merge-commit.sample
+ /.git/hooks/push-to-checkout.sample
+ /.git/hooks/fsmonitor-watchman.sample
+ /.git/hooks/prepare-commit-msg.sample
+ /.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
+ /.git/objects/05/054a55af449d7a3d22569a0d9278837d3116b7
+ /.git/objects/05/aa0754159021ad4bb196249ebed23fcaee0f05
+ /.git/objects/0d/90a95e4569ab236f012c54a903f79e23f7e45d
+ /.git/objects/0f/05624ad8de377d4bdf3ec1558d477af125661c
+ /.git/objects/11/6f5b50e2bd7e5a645224f577c702fc62092122
+ /.git/objects/1a/49d62b998226393c172907eef021434d19be9a
+ /.git/objects/1f/b9dc988a5179e983b847d789447e3c5fa79e57
+ /.git/objects/26/3963a64f2a64659282fd9cbe561dd7a5e4a676
+ /.git/objects/2b/5f9208bfadbbc9019b47a713b74462b9cd2613
+ /.git/objects/30/6f36bddc52f2e08ccf8a41536340870eb1829c
+ /.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
+ /.git/objects/39/5d98ffb25a1aa9df31eb7f0e6c2af2e28bc31d
+ /.git/objects/3c/91061820fd12503e015c3c19cec90b78494358
+ /.git/objects/43/34e267d8776aabbeb38713c0a502fa328ceb68
+ /.git/objects/49/554703073ae63a7122c05b80a894ac3ff48370
+ /.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
+ /.git/objects/5c/98b428844d9f7d529e2b6fb918d15bf072f3df
+ /.git/objects/65/427e6010f1b59257bc8ac509401e7eeb2698d4
+ /.git/objects/68/2820a134168b0d23787b376165bef89b511f00
+ /.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
+ /.git/objects/7d/61ee6e1564fdc3e562582a8ca1c55185fd2b09
+ /.git/objects/80/8df08d052527e9a626a08c732fb0fb470708c8
+ /.git/objects/8b/e37e197c873cbcd2952f364d9e3a447bc4e692
+ /.git/objects/8c/333a97e7dbd1f8d32d947ad097e8e247f9f041
+ /.git/objects/91/4c3a82a059ff11e1e2248c3ee1ce32a78bc63a
+ /.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
+ /.git/objects/9c/780ff1eacdac600ca19795de4e5f1220a1bf3e
+ /.git/objects/aa/90a9d65e85ba8dedaeee57dbca845093794f15
+ /.git/objects/aa/d3f0402094e10cd99e06ba2a544a57396b1919
+ /.git/objects/ae/39a65a74d4111e721807c06e27bd6754992fbb
+ /.git/objects/b4/a758f2f8c8a18b851825e056e555c5620ae676
+ /.git/objects/b6/90d19ac158bfa6e1ae11cef101f0d1a7434bd9
+ /.git/objects/c2/828bc31a68ae45ce1922d19323206b232cbda4
+ /.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
+ /.git/objects/ca/22da9b6c126b0744cfde03b32ebdff29cb41ab
+ /.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
+ /.git/objects/d2/e73db08c8563911c081a8651a77f67c4b48b43
+ /.git/objects/de/c87ed246fc3ca006dddb4db1972a0e1d67919e
+ /.git/objects/e2/3a8b692a016f63a83e1997a2326d3be18d8d1e
+ /.git/objects/e5/f5f06b6f0fb91e529051f1cb6651cc60ce2f48
+ /.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
+ /.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
+ /.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
+ /.git/objects/ef/89a8450022222b69a62814d66e3f6c8ecb5a60
+ /.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
+ /.git/objects/f6/cca8a6084310f182dc287fadbb82c5ebcfffe8
+ /.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
+ /.git/HEAD
+ /.git/index
+ /.git/config
+ /.git/description
+ /.git/COMMIT_EDITMSG

--[ 2022.11.11.13.29.57.388.0 ]--
UpdateTree (AD): 1 0
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_11_22,_1_29_PM_[Default]/shelved.patch

--[ 2022.11.11.13.29.57.425.0 ]--
UpdateTree (AD): 1 0
+ /.idea/shelf/Uncommitted_changes_before_Update_at_11_11_22__1_29_PM__Default_.xml

--[ 2022.11.11.13.30.43.260.0 ]--
UpdateTree (AD): 2 0
+ /.git/ORIG_HEAD
+ /.git/FETCH_HEAD

--[ 2022.11.11.13.40.15.511.0 ]--
:/src/PSKDTree.java
+ 17     public PSKDTree() { 
r 18     }
--[ 2022.11.11.13.40.16.006.0 ]--
+ 18         
--[ 2022.11.11.13.40.25.154.0 ]--
r 15     
--[ 2022.11.11.13.40.25.526.0 ]--
+ 15     
--[ 2022.11.11.13.40.25.818.0 ]--
r 16         
--[ 2022.11.11.13.40.26.525.0 ]--
r 16     
--[ 2022.11.11.13.41.19.526.0 ]--
r 15 
r 16 
r 18     public PSKDTree() {
--[ 2022.11.11.13.42.29.694.0 ]--
r 19         BST<String, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.56.385.0 ]--
r 19         BST<Pa, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.56.971.0 ]--
r 19         BST<P, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.57.517.0 ]--
r 19         BST<Po, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.57.672.0 ]--
r 19         BST<Poi, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.57.725.0 ]--
r 19         BST<Poin, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.57.933.0 ]--
r 19         BST<Point, Integer> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.59.625.0 ]--
r 19         BST<Point, V> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.59.751.0 ]--
r 19         BST<Point, Va> st = new BST<String, Integer>();
--[ 2022.11.11.13.42.59.791.0 ]--
r 19         BST<Point, Val> st = new BST<String, Integer>();
--[ 2022.11.11.13.43.00.043.0 ]--
r 19         BST<Point, Valu> st = new BST<String, Integer>();
--[ 2022.11.11.13.43.00.079.0 ]--
r 19         BST<Point, Value> st = new BST<String, Integer>();
--[ 2022.11.11.13.43.01.661.0 ]--
r 19         BST<Point, Value> st = new BST<P, Integer>();
--[ 2022.11.11.13.43.01.779.0 ]--
r 19         BST<Point, Value> st = new BST<Po, Integer>();
--[ 2022.11.11.13.43.01.887.0 ]--
r 19         BST<Point, Value> st = new BST<Poi, Integer>();
--[ 2022.11.11.13.43.02.039.0 ]--
r 19         BST<Point, Value> st = new BST<Poin, Integer>();
--[ 2022.11.11.13.43.02.312.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Integer>();
--[ 2022.11.11.13.43.03.932.0 ]--
r 19         BST<Point, Value> st = new BST<Point, V>();
--[ 2022.11.11.13.43.04.135.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Va>();
--[ 2022.11.11.13.43.04.328.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Val>();
--[ 2022.11.11.13.43.04.449.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Valu>();
--[ 2022.11.11.13.43.04.551.0 ]--
r 19         BST<Point, Value> st = new BST<Point, Value>();
--[ 2022.11.11.13.43.07.204.0 ]--
r 19         
--[ 2022.11.11.13.43.08.931.0 ]--
r 15 BST<Point, Value> st = new BST<Point, Value>();
--[ 2022.11.11.13.43.09.019.0 ]--
r 15     BST<Point, Value> st = new BST<Point, Value>();
--[ 2022.11.11.13.43.11.360.0 ]--
r 15     BST<Point, Value> s = new BST<Point, Value>();
--[ 2022.11.11.13.43.11.777.0 ]--
r 15     BST<Point, Value>  = new BST<Point, Value>();
--[ 2022.11.11.13.43.32.364.0 ]--
r 15     BST<Point, Value> k = new BST<Point, Value>();
--[ 2022.11.11.13.43.32.551.0 ]--
r 15     BST<Point, Value> ki = new BST<Point, Value>();
--[ 2022.11.11.13.43.32.810.0 ]--
r 15     BST<Point, Value> kid = new BST<Point, Value>();
--[ 2022.11.11.13.43.33.138.0 ]--
r 15     BST<Point, Value> ki = new BST<Point, Value>();
--[ 2022.11.11.13.43.33.284.0 ]--
r 15     BST<Point, Value> k = new BST<Point, Value>();
--[ 2022.11.11.13.43.33.381.0 ]--
r 15     BST<Point, Value> kd = new BST<Point, Value>();
--[ 2022.11.11.13.43.33.621.0 ]--
r 15     BST<Point, Value> kdt = new BST<Point, Value>();
--[ 2022.11.11.13.43.48.111.0 ]--
r 15     BST<Point, Value> kdt; = new BST<Point, Value>();
--[ 2022.11.11.13.43.50.918.0 ]--
r 15     BST<Point, Value> kdt; 
--[ 2022.11.11.13.43.51.897.0 ]--
r 19         k
--[ 2022.11.11.13.43.52.190.0 ]--
r 19         kd
--[ 2022.11.11.13.43.52.959.0 ]--
r 19         kdt
--[ 2022.11.11.13.43.53.077.0 ]--
r 19         kdt=
--[ 2022.11.11.13.43.53.255.0 ]--
r 19         kdt== new BST<Point, Value>();
--[ 2022.11.11.13.43.59.665.0 ]--
r 19         kdt== new BST();
--[ 2022.11.11.13.44.12.650.0 ]--
r 19         kdt== new BST<Point, Value>();
--[ 2022.11.11.13.44.15.316.0 ]--
r 19         kdt= new BST<Point, Value>();
--[ 2022.11.11.13.44.19.219.0 ]--
r 19         kdt = new BST<Point, Value>();
--[ 2022.11.11.13.44.31.105.0 ]--
r 23     public void put(Point p, Value v) {''
--[ 2022.11.11.13.44.39.214.0 ]--
r 23     public void put(Point p, Value v) {'
--[ 2022.11.11.13.44.39.351.0 ]--
r 23     public void put(Point p, Value v) {
--[ 2022.11.11.13.45.33.022.0 ]--
r 15     BST<Point, Value> kdt;
--[ 2022.11.11.13.46.48.583.0 ]--
+ 24         
--[ 2022.11.11.13.46.50.719.0 ]--
r 24         k
--[ 2022.11.11.13.46.51.186.0 ]--
r 24         kd
--[ 2022.11.11.13.46.51.420.0 ]--
r 24         kdt
--[ 2022.11.11.13.46.51.572.0 ]--
r 24         kdt.
--[ 2022.11.11.13.46.52.148.0 ]--
r 24         kdt.p
--[ 2022.11.11.13.46.52.539.0 ]--
r 24         kdt.pu
--[ 2022.11.11.13.46.53.008.0 ]--
r 24         kdt.put
--[ 2022.11.11.13.46.56.733.0 ]--
r 24         kdt.put()
--[ 2022.11.11.13.46.58.718.0 ]--
r 24         kdt.put(p,)
--[ 2022.11.11.13.46.58.944.0 ]--
r 24         kdt.put(p,v)
--[ 2022.11.11.13.47.00.106.0 ]--
r 24         kdt.put(p,v);
--[ 2022.11.11.13.47.11.832.0 ]--
+ 71         
--[ 2022.11.11.13.47.25.921.0 ]--
r 71         P
--[ 2022.11.11.13.47.26.221.0 ]--
r 71         PS
--[ 2022.11.11.13.47.26.558.0 ]--
r 71         PSK
--[ 2022.11.11.13.47.26.883.0 ]--
r 71         PSKD
--[ 2022.11.11.13.47.27.568.0 ]--
r 71         PSKDT
--[ 2022.11.11.13.47.27.893.0 ]--
r 71         PSKDTr
--[ 2022.11.11.13.47.28.401.0 ]--
r 71         PSKDTre
--[ 2022.11.11.13.47.28.941.0 ]--
r 71         PSKDTree
--[ 2022.11.11.13.47.33.880.0 ]--
r 71         PSKDTree<>
--[ 2022.11.11.13.47.34.343.0 ]--
r 71         PSKDTree<i>
--[ 2022.11.11.13.47.34.526.0 ]--
r 71         PSKDTree<in>
--[ 2022.11.11.13.47.34.729.0 ]--
r 71         PSKDTree<int>
--[ 2022.11.11.13.47.36.112.0 ]--
r 71         PSKDTree<int
--[ 2022.11.11.13.47.36.452.0 ]--
r 71         PSKDTree<in
--[ 2022.11.11.13.47.36.587.0 ]--
r 71         PSKDTree<i
--[ 2022.11.11.13.47.36.683.0 ]--
r 71         PSKDTree<
--[ 2022.11.11.13.47.37.110.0 ]--
r 71         PSKDTree<I
--[ 2022.11.11.13.47.37.216.0 ]--
r 71         PSKDTree<In
--[ 2022.11.11.13.47.37.333.0 ]--
r 71         PSKDTree<Int
--[ 2022.11.11.13.47.37.628.0 ]--
r 71         PSKDTree<Inte
--[ 2022.11.11.13.47.37.977.0 ]--
r 71         PSKDTree<Integ
--[ 2022.11.11.13.47.38.136.0 ]--
r 71         PSKDTree<Intege
--[ 2022.11.11.13.47.38.235.0 ]--
r 71         PSKDTree<Integer
--[ 2022.11.11.13.47.38.786.0 ]--
r 71         PSKDTree<Integer>
--[ 2022.11.11.13.47.39.026.0 ]--
r 71         PSKDTree<Integer> 
--[ 2022.11.11.13.47.42.811.0 ]--
r 71         PSKDTree<Integer> =
--[ 2022.11.11.13.47.42.936.0 ]--
r 71         PSKDTree<Integer> = 
--[ 2022.11.11.13.47.43.519.0 ]--
r 71         PSKDTree<Integer> =
--[ 2022.11.11.13.47.43.649.0 ]--
r 71         PSKDTree<Integer> 
--[ 2022.11.11.13.47.43.814.0 ]--
r 71         PSKDTree<Integer>
--[ 2022.11.11.13.47.44.256.0 ]--
r 71         PSKDTree<Integer> 
--[ 2022.11.11.13.47.45.553.0 ]--
r 71         PSKDTree<Integer> t
--[ 2022.11.11.13.47.45.690.0 ]--
r 71         PSKDTree<Integer> te
--[ 2022.11.11.13.47.45.756.0 ]--
r 71         PSKDTree<Integer> tes
--[ 2022.11.11.13.47.45.888.0 ]--
r 71         PSKDTree<Integer> test
--[ 2022.11.11.13.47.46.052.0 ]--
r 71         PSKDTree<Integer> test 
--[ 2022.11.11.13.47.46.165.0 ]--
r 71         PSKDTree<Integer> test =
--[ 2022.11.11.13.47.46.279.0 ]--
r 71         PSKDTree<Integer> test = 
--[ 2022.11.11.13.47.49.153.0 ]--
r 71         PSKDTree<Integer> test = n
--[ 2022.11.11.13.47.49.286.0 ]--
r 71         PSKDTree<Integer> test = ne
--[ 2022.11.11.13.47.49.409.0 ]--
r 71         PSKDTree<Integer> test = new
--[ 2022.11.11.13.47.49.768.0 ]--
r 71         PSKDTree<Integer> test = new 
--[ 2022.11.11.13.47.50.759.0 ]--
r 71         PSKDTree<Integer> test = new P
--[ 2022.11.11.13.47.51.513.0 ]--
r 71         PSKDTree<Integer> test = new PS
--[ 2022.11.11.13.47.52.104.0 ]--
r 71         PSKDTree<Integer> test = new PSK
--[ 2022.11.11.13.47.52.667.0 ]--
r 71         PSKDTree<Integer> test = new PSKD
--[ 2022.11.11.13.47.52.990.0 ]--
r 71         PSKDTree<Integer> test = new PSKDT
--[ 2022.11.11.13.47.53.188.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTr
--[ 2022.11.11.13.47.53.377.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTre
--[ 2022.11.11.13.47.53.544.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree
--[ 2022.11.11.13.47.54.582.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree()
--[ 2022.11.11.13.47.55.849.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(I)
--[ 2022.11.11.13.47.56.019.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(In)
--[ 2022.11.11.13.47.56.499.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Int)
--[ 2022.11.11.13.47.57.091.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Inte)
--[ 2022.11.11.13.47.57.370.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Integ)
--[ 2022.11.11.13.47.57.689.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Intege)
--[ 2022.11.11.13.47.57.753.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Integer)
--[ 2022.11.11.13.48.05.897.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Integer
--[ 2022.11.11.13.48.06.007.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Intege
--[ 2022.11.11.13.48.06.156.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Integ
--[ 2022.11.11.13.48.06.304.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Inte
--[ 2022.11.11.13.48.06.465.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(Int
--[ 2022.11.11.13.48.06.618.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(In
--[ 2022.11.11.13.48.06.781.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(I
--[ 2022.11.11.13.48.06.925.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree(
--[ 2022.11.11.13.48.07.076.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree
--[ 2022.11.11.13.48.07.745.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<>
--[ 2022.11.11.13.48.08.254.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<I>
--[ 2022.11.11.13.48.08.390.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<In>
--[ 2022.11.11.13.48.08.709.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Int>
--[ 2022.11.11.13.48.09.053.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Inte>
--[ 2022.11.11.13.48.09.224.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integ>
--[ 2022.11.11.13.48.09.368.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Intege>
--[ 2022.11.11.13.48.09.477.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integer>
--[ 2022.11.11.13.48.10.289.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integer>()
--[ 2022.11.11.13.48.10.653.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integer>();
--[ 2022.11.11.13.48.11.104.0 ]--
r 71         PSKDTree<Integer> test = new PSKDTree<Integer>(); 
--[ 2022.11.11.13.48.15.385.0 ]--
+ 72         
--[ 2022.11.11.13.48.16.435.0 ]--
r 72         t
--[ 2022.11.11.13.48.16.549.0 ]--
r 72         te
--[ 2022.11.11.13.48.16.729.0 ]--
r 72         tes
--[ 2022.11.11.13.48.17.015.0 ]--
r 72         test
--[ 2022.11.11.13.48.17.234.0 ]--
r 72         test.
--[ 2022.11.11.13.48.17.564.0 ]--
r 72         test.p
--[ 2022.11.11.13.48.17.898.0 ]--
r 72         test.pu
--[ 2022.11.11.13.48.18.269.0 ]--
r 72         test.put
--[ 2022.11.11.13.48.34.135.0 ]--
r 72         test.put()
--[ 2022.11.11.13.48.45.783.0 ]--
+ 71         
--[ 2022.11.11.13.48.46.664.0 ]--
r 71         P
--[ 2022.11.11.13.48.47.204.0 ]--
r 71         Po
--[ 2022.11.11.13.48.47.463.0 ]--
r 71         Poi
--[ 2022.11.11.13.48.48.142.0 ]--
r 71         Poin
--[ 2022.11.11.13.48.48.700.0 ]--
r 71         Point
--[ 2022.11.11.13.48.49.081.0 ]--
r 71         Point 
--[ 2022.11.11.13.48.49.552.0 ]--
r 71         Point  
--[ 2022.11.11.13.48.50.163.0 ]--
r 71         Point  t
--[ 2022.11.11.13.48.50.514.0 ]--
r 71         Point  
--[ 2022.11.11.13.48.50.654.0 ]--
r 71         Point 
--[ 2022.11.11.13.48.50.767.0 ]--
r 71         Point
--[ 2022.11.11.13.48.51.277.0 ]--
r 71         Point 
--[ 2022.11.11.13.48.51.602.0 ]--
r 71         Point x
--[ 2022.11.11.13.48.51.995.0 ]--
r 71         Point x 
--[ 2022.11.11.13.48.52.445.0 ]--
r 71         Point x =
--[ 2022.11.11.13.48.52.827.0 ]--
r 71         Point x = 
--[ 2022.11.11.13.49.00.733.0 ]--
r 71         Point x = ne
--[ 2022.11.11.13.49.00.873.0 ]--
r 71         Point x = new
--[ 2022.11.11.13.49.01.015.0 ]--
r 71         Point x = new 
--[ 2022.11.11.13.49.01.267.0 ]--
r 71         Point x = new P
--[ 2022.11.11.13.49.01.687.0 ]--
r 71         Point x = new Po
--[ 2022.11.11.13.49.01.788.0 ]--
r 71         Point x = new Poi
--[ 2022.11.11.13.49.01.852.0 ]--
r 71         Point x = new Poin
--[ 2022.11.11.13.49.01.948.0 ]--
r 71         Point x = new Point
--[ 2022.11.11.13.49.02.430.0 ]--
r 71         Point x = new Point()
--[ 2022.11.11.13.49.03.654.0 ]--
r 71         Point x = new Point(1)
--[ 2022.11.11.13.49.03.733.0 ]--
r 71         Point x = new Point(1.)
--[ 2022.11.11.13.49.03.892.0 ]--
r 71         Point x = new Point(1.0)
--[ 2022.11.11.13.49.04.091.0 ]--
r 71         Point x = new Point(1.0,)
--[ 2022.11.11.13.49.04.686.0 ]--
r 71         Point x = new Point(1.0,2.0)
--[ 2022.11.11.13.49.06.068.0 ]--
r 71         Point x = new Point(1.0,2.0);
--[ 2022.11.11.13.49.10.406.0 ]--
r 73         test.put(x)
--[ 2022.11.11.13.49.10.672.0 ]--
r 73         test.put(x,)
--[ 2022.11.11.13.49.11.240.0 ]--
r 73         test.put(x, )
--[ 2022.11.11.13.49.12.242.0 ]--
r 73         test.put(x, 3)
--[ 2022.11.11.13.49.13.407.0 ]--
r 73         test.put(x, 3);
--[ 2022.11.11.13.49.50.158.0 ]--
+ 74         
--[ 2022.11.11.13.49.50.414.0 ]--
r 74         f
--[ 2022.11.11.13.49.50.658.0 ]--
r 74         fo
--[ 2022.11.11.13.49.50.942.0 ]--
r 74         for
--[ 2022.11.11.13.49.51.214.0 ]--
r 74         for 
--[ 2022.11.11.13.49.52.235.0 ]--
r 74         for ()
--[ 2022.11.11.13.49.55.379.0 ]--
r 74         for (S)
--[ 2022.11.11.13.49.56.322.0 ]--
r 74         for (ST)
--[ 2022.11.11.13.49.56.614.0 ]--
r 74         for (STr)
--[ 2022.11.11.13.49.57.065.0 ]--
r 74         for (ST)
--[ 2022.11.11.13.49.57.141.0 ]--
r 74         for (S)
--[ 2022.11.11.13.49.57.266.0 ]--
r 74         for (St)
--[ 2022.11.11.13.49.57.531.0 ]--
r 74         for (Str)
--[ 2022.11.11.13.49.58.313.0 ]--
r 74         for (String)
--[ 2022.11.11.13.49.58.618.0 ]--
r 74         for (String )
--[ 2022.11.11.13.49.59.610.0 ]--
r 74         for (String)
--[ 2022.11.11.13.49.59.663.0 ]--
r 74         for (Strin)
--[ 2022.11.11.13.49.59.791.0 ]--
r 74         for (Stri)
--[ 2022.11.11.13.49.59.939.0 ]--
r 74         for (Str)
--[ 2022.11.11.13.50.00.086.0 ]--
r 74         for (St)
--[ 2022.11.11.13.50.00.221.0 ]--
r 74         for (S)
--[ 2022.11.11.13.50.00.365.0 ]--
r 74         for ()
--[ 2022.11.11.13.50.09.894.0 ]--
r 74         for (P)
--[ 2022.11.11.13.50.10.206.0 ]--
r 74         for (Po)
--[ 2022.11.11.13.50.10.269.0 ]--
r 74         for (Poi)
--[ 2022.11.11.13.50.10.367.0 ]--
r 74         for (Poin)
--[ 2022.11.11.13.50.10.572.0 ]--
r 74         for (Point)
--[ 2022.11.11.13.50.11.554.0 ]--
r 74         for (Point )
--[ 2022.11.11.13.50.12.059.0 ]--
r 74         for (Point s)
--[ 2022.11.11.13.50.12.401.0 ]--
r 74         for (Point s:)
--[ 2022.11.11.13.50.13.502.0 ]--
r 74         for (Point s:s)
--[ 2022.11.11.13.50.13.802.0 ]--
r 74         for (Point s:st)
--[ 2022.11.11.13.50.14.623.0 ]--
r 74         for (Point s:s)
--[ 2022.11.11.13.50.14.736.0 ]--
r 74         for (Point s:)
--[ 2022.11.11.13.50.17.814.0 ]--
r 74         for (Point s:t)
--[ 2022.11.11.13.50.18.282.0 ]--
r 74         for (Point s:te)
--[ 2022.11.11.13.50.18.397.0 ]--
r 74         for (Point s:tes)
--[ 2022.11.11.13.50.18.587.0 ]--
r 74         for (Point s:test)
--[ 2022.11.11.13.50.19.707.0 ]--
r 74         for (Point s:test.)
--[ 2022.11.11.13.50.20.029.0 ]--
r 74         for (Point s:test.k)
--[ 2022.11.11.13.50.20.196.0 ]--
r 74         for (Point s:test.ke)
--[ 2022.11.11.13.50.20.360.0 ]--
r 74         for (Point s:test.key)
--[ 2022.11.11.13.50.20.853.0 ]--
r 74         for (Point s:test.keys)
--[ 2022.11.11.13.50.21.434.0 ]--
r 74         for (Point s:test.keys())
--[ 2022.11.11.13.50.30.971.0 ]--
r 74         
--[ 2022.11.11.13.50.34.300.0 ]--
- 71
- 71
r 71         
--[ 2022.11.11.13.50.34.836.0 ]--
- 71
--[ 2022.11.11.13.50.35.541.0 ]--
r 70     public static void main(String[] args) 
--[ 2022.11.11.13.50.36.571.0 ]--
r 70     public static void main(String[] args) {
--[ 2022.11.11.13.50.38.288.0 ]--
- 71
--[ 2022.11.11.13.51.18.405.0 ]--
r 23     public void put(Point p, Value v) { 
--[ 2022.11.11.13.51.18.465.0 ]--
r 23     public void put(Point p, Value v) {  
--[ 2022.11.11.13.51.19.128.0 ]--
r 23     public void put(Point p, Value v) {  /
--[ 2022.11.11.13.51.19.240.0 ]--
r 23     public void put(Point p, Value v) {  //
--[ 2022.11.11.13.51.19.740.0 ]--
r 23     public void put(Point p, Value v) {  //c
--[ 2022.11.11.13.51.19.908.0 ]--
r 23     public void put(Point p, Value v) {  //ca
--[ 2022.11.11.13.51.20.059.0 ]--
r 23     public void put(Point p, Value v) {  //cah
--[ 2022.11.11.13.51.20.264.0 ]--
r 23     public void put(Point p, Value v) {  //cahn
--[ 2022.11.11.13.51.20.368.0 ]--
r 23     public void put(Point p, Value v) {  //cahng
--[ 2022.11.11.13.51.20.574.0 ]--
r 23     public void put(Point p, Value v) {  //cahnge
--[ 2022.11.11.13.51.21.732.0 ]--
r 23     public void put(Point p, Value v) {  //cahng
--[ 2022.11.11.13.51.21.839.0 ]--
r 23     public void put(Point p, Value v) {  //cahn
--[ 2022.11.11.13.51.22.013.0 ]--
r 23     public void put(Point p, Value v) {  //cah
--[ 2022.11.11.13.51.22.158.0 ]--
r 23     public void put(Point p, Value v) {  //ca
--[ 2022.11.11.13.51.22.291.0 ]--
r 23     public void put(Point p, Value v) {  //c
--[ 2022.11.11.13.51.22.683.0 ]--
r 23     public void put(Point p, Value v) {  //ch
--[ 2022.11.11.13.51.22.789.0 ]--
r 23     public void put(Point p, Value v) {  //cha
--[ 2022.11.11.13.51.22.873.0 ]--
r 23     public void put(Point p, Value v) {  //chan
--[ 2022.11.11.13.51.23.126.0 ]--
r 23     public void put(Point p, Value v) {  //chang
--[ 2022.11.11.13.51.23.843.0 ]--
r 23     public void put(Point p, Value v) {  //change
--[ 2022.11.11.13.51.24.402.0 ]--
r 23     public void put(Point p, Value v) {  //change?
--[ 2022.11.11.13.51.24.531.0 ]--
r 23     public void put(Point p, Value v) {  //change??
--[ 2022.11.11.13.54.01.140.0 ]--
+ 16     
--[ 2022.11.11.13.54.02.807.0 ]--
r 16     i
--[ 2022.11.11.13.54.02.870.0 ]--
r 16     in
--[ 2022.11.11.13.54.03.141.0 ]--
r 16     int
--[ 2022.11.11.13.54.03.175.0 ]--
r 16     int 
--[ 2022.11.11.13.54.03.412.0 ]--
r 16     int s
--[ 2022.11.11.13.54.03.507.0 ]--
r 16     int si
--[ 2022.11.11.13.54.03.759.0 ]--
r 16     int siz
--[ 2022.11.11.13.54.04.043.0 ]--
r 16     int size
--[ 2022.11.11.13.54.04.600.0 ]--
r 16     int size;
--[ 2022.11.11.13.54.06.885.0 ]--
r 16     int c;
--[ 2022.11.11.13.54.06.997.0 ]--
r 16     int cp;
--[ 2022.11.11.13.54.07.045.0 ]--
r 16     int cpo;
--[ 2022.11.11.13.54.07.392.0 ]--
r 16     int cp;
--[ 2022.11.11.13.54.07.503.0 ]--
r 16     int c;
--[ 2022.11.11.13.54.08.109.0 ]--
r 16     int co;
--[ 2022.11.11.13.54.08.196.0 ]--
r 16     int cou;
--[ 2022.11.11.13.54.08.387.0 ]--
r 16     int coun;
--[ 2022.11.11.13.54.08.516.0 ]--
r 16     int count;
--[ 2022.11.11.13.54.14.019.0 ]--
r 16     int count=;
--[ 2022.11.11.13.54.14.177.0 ]--
r 16     int count=0;
--[ 2022.11.11.13.54.17.530.0 ]--
+ 26         
--[ 2022.11.11.13.54.17.886.0 ]--
r 26         c
--[ 2022.11.11.13.54.17.979.0 ]--
r 26         co
--[ 2022.11.11.13.54.18.147.0 ]--
r 26         cou
--[ 2022.11.11.13.54.18.250.0 ]--
r 26         cout
--[ 2022.11.11.13.54.18.566.0 ]--
r 26         cout+
--[ 2022.11.11.13.54.18.690.0 ]--
r 26         cout++
--[ 2022.11.11.13.54.18.879.0 ]--
r 26         cout++;
--[ 2022.11.11.13.54.21.288.0 ]--
r 26         count++;
--[ 2022.11.11.13.54.30.943.0 ]--
r 69     public boolean isEmpty() { return tc; }
--[ 2022.11.11.13.54.31.214.0 ]--
r 69     public boolean isEmpty() { return t; }
--[ 2022.11.11.13.54.31.339.0 ]--
r 69     public boolean isEmpty() { return ; }
--[ 2022.11.11.13.54.31.684.0 ]--
r 69     public boolean isEmpty() { return c; }
--[ 2022.11.11.13.54.31.964.0 ]--
r 69     public boolean isEmpty() { return co; }
--[ 2022.11.11.13.54.32.140.0 ]--
r 69     public boolean isEmpty() { return cou; }
--[ 2022.11.11.13.54.32.407.0 ]--
r 69     public boolean isEmpty() { return coun; }
--[ 2022.11.11.13.54.32.527.0 ]--
r 69     public boolean isEmpty() { return count; }
--[ 2022.11.11.13.54.32.809.0 ]--
r 69     public boolean isEmpty() { return count=; }
--[ 2022.11.11.13.54.33.172.0 ]--
r 69     public boolean isEmpty() { return count==; }
--[ 2022.11.11.13.54.33.441.0 ]--
r 69     public boolean isEmpty() { return count==0; }
--[ 2022.11.11.13.54.35.263.0 ]--
r 66     public int size() { return ; }
--[ 2022.11.11.13.54.35.523.0 ]--
r 66     public int size() { return c; }
--[ 2022.11.11.13.54.35.732.0 ]--
r 66     public int size() { return co; }
--[ 2022.11.11.13.54.35.783.0 ]--
r 66     public int size() { return cou; }
--[ 2022.11.11.13.54.36.007.0 ]--
r 66     public int size() { return coun; }
--[ 2022.11.11.13.54.36.163.0 ]--
r 66     public int size() { return count; }
--[ 2022.11.11.13.55.15.679.0 ]--
r 17     
--[ 2022.11.11.13.55.49.049.0 ]--
r 17     e
--[ 2022.11.11.13.55.51.175.0 ]--
r 17     
--[ 2022.11.11.13.55.58.305.0 ]--
r 17     P
--[ 2022.11.11.13.55.58.501.0 ]--
r 17     Po
--[ 2022.11.11.13.55.58.602.0 ]--
r 17     Poi
--[ 2022.11.11.13.55.58.716.0 ]--
r 17     Poin
--[ 2022.11.11.13.55.58.884.0 ]--
r 17     Point
--[ 2022.11.11.13.55.58.990.0 ]--
r 17     Point 
--[ 2022.11.11.13.55.59.084.0 ]--
r 17     Point m
--[ 2022.11.11.13.55.59.223.0 ]--
r 17     Point mi
--[ 2022.11.11.13.55.59.433.0 ]--
r 17     Point min
--[ 2022.11.11.13.55.59.806.0 ]--
r 17     Point mini
--[ 2022.11.11.13.56.00.554.0 ]--
r 17     Point minim
--[ 2022.11.11.13.56.00.722.0 ]--
r 17     Point minimu
--[ 2022.11.11.13.56.00.898.0 ]--
r 17     Point minimun
--[ 2022.11.11.13.56.01.588.0 ]--
r 17     Point minimu
--[ 2022.11.11.13.56.01.903.0 ]--
r 17     Point minimum
--[ 2022.11.11.13.56.02.160.0 ]--
r 17     Point minimum;
--[ 2022.11.11.13.56.02.462.0 ]--
+ 18     
--[ 2022.11.11.13.56.03.745.0 ]--
r 18     Poi
--[ 2022.11.11.13.56.03.960.0 ]--
r 18     Poin
--[ 2022.11.11.13.56.04.416.0 ]--
r 18     Point
--[ 2022.11.11.13.56.07.165.0 ]--
r 18     Point 
--[ 2022.11.11.13.56.07.286.0 ]--
r 18     Point m
--[ 2022.11.11.13.56.07.525.0 ]--
r 18     Point ma
--[ 2022.11.11.13.56.08.320.0 ]--
r 18     Point max
--[ 2022.11.11.13.56.08.539.0 ]--
r 18     Point maxi
--[ 2022.11.11.13.56.08.828.0 ]--
r 18     Point maxim
--[ 2022.11.11.13.56.09.067.0 ]--
r 18     Point maximu
--[ 2022.11.11.13.56.09.274.0 ]--
r 18     Point maximum
--[ 2022.11.11.13.56.09.630.0 ]--
r 18     Point maximum;
--[ 2022.11.11.21.34.27.936.0 ]--
+ 63     public Point min() { 
r 64         return null; }
--[ 2022.11.11.21.34.29.308.0 ]--
+ 64         return null; 
r 65     }
--[ 2022.11.11.21.34.30.933.0 ]--
+ 64         
--[ 2022.11.11.21.34.31.376.0 ]--
r 64         i
--[ 2022.11.11.21.34.31.487.0 ]--
r 64         if
--[ 2022.11.11.21.34.32.190.0 ]--
r 64         if()
--[ 2022.11.11.21.34.32.350.0 ]--
r 64         if(i)
--[ 2022.11.11.21.34.32.488.0 ]--
r 64         if(is)
--[ 2022.11.11.21.34.32.855.0 ]--
r 64         if(isE)
--[ 2022.11.11.21.34.32.964.0 ]--
r 64         if(isEm)
--[ 2022.11.11.21.34.34.069.0 ]--
r 64         if(isEmp)
--[ 2022.11.11.21.34.34.349.0 ]--
r 64         if(isEmpt)
--[ 2022.11.11.21.34.34.924.0 ]--
r 64         if(isEmpty)
--[ 2022.11.11.21.34.35.480.0 ]--
r 64         if(isEmpty())
--[ 2022.11.11.21.34.38.678.0 ]--
r 64         if(isEmpty()) 
--[ 2022.11.11.21.34.38.832.0 ]--
r 64         if(isEmpty()) r
--[ 2022.11.11.21.34.39.106.0 ]--
r 64         if(isEmpty()) re
--[ 2022.11.11.21.34.39.276.0 ]--
r 64         if(isEmpty()) ret
--[ 2022.11.11.21.34.39.386.0 ]--
r 64         if(isEmpty()) retu
--[ 2022.11.11.21.34.39.512.0 ]--
r 64         if(isEmpty()) retur
--[ 2022.11.11.21.34.39.973.0 ]--
r 64         if(isEmpty()) return
--[ 2022.11.11.21.34.40.145.0 ]--
r 64         if(isEmpty()) return 
--[ 2022.11.11.21.34.40.328.0 ]--
r 64         if(isEmpty()) return n
--[ 2022.11.11.21.34.40.516.0 ]--
r 64         if(isEmpty()) return nu
--[ 2022.11.11.21.34.40.747.0 ]--
r 64         if(isEmpty()) return nul
--[ 2022.11.11.21.34.40.874.0 ]--
r 64         if(isEmpty()) return null
--[ 2022.11.11.21.34.41.339.0 ]--
r 64         if(isEmpty()) return null;
--[ 2022.11.11.21.34.45.856.0 ]--
r 65        
--[ 2022.11.11.21.34.46.234.0 ]--
- 65
--[ 2022.11.11.21.34.53.260.0 ]--
r 66     public Point max() { if(isEmpty()) return null; }
--[ 2022.11.11.21.34.54.359.0 ]--
+ 66     public Point max() { if(isEmpty()) return null;
r 67     }
--[ 2022.11.11.21.34.55.758.0 ]--
+ 66     public Point max() { 
r 67         if(isEmpty()) return null;
--[ 2022.11.11.21.34.58.794.0 ]--
+ 68         
--[ 2022.11.11.21.35.00.513.0 ]--
r 68         r
--[ 2022.11.11.21.35.00.626.0 ]--
r 68         re
--[ 2022.11.11.21.35.00.779.0 ]--
r 68         ret
--[ 2022.11.11.21.35.01.811.0 ]--
r 68         retu
--[ 2022.11.11.21.35.02.177.0 ]--
r 68         retur
--[ 2022.11.11.21.35.02.273.0 ]--
r 68         return
--[ 2022.11.11.21.35.02.416.0 ]--
r 68         return 
--[ 2022.11.11.21.35.02.975.0 ]--
r 68         return n
--[ 2022.11.11.21.35.03.183.0 ]--
r 68         return nu
--[ 2022.11.11.21.35.03.389.0 ]--
r 68         return nul
--[ 2022.11.11.21.35.04.092.0 ]--
r 68         return null
--[ 2022.11.11.21.35.04.246.0 ]--
r 68         return null;
--[ 2022.11.11.21.35.05.563.0 ]--
+ 65         
--[ 2022.11.11.21.35.05.831.0 ]--
r 65         r
--[ 2022.11.11.21.35.05.989.0 ]--
r 65         re
--[ 2022.11.11.21.35.06.169.0 ]--
r 65         ret
--[ 2022.11.11.21.35.06.524.0 ]--
r 65         retu
--[ 2022.11.11.21.35.06.738.0 ]--
r 65         retur
--[ 2022.11.11.21.35.06.908.0 ]--
r 65         return
--[ 2022.11.11.21.35.07.332.0 ]--
r 65         return 
--[ 2022.11.11.21.35.07.653.0 ]--
r 65         return n
--[ 2022.11.11.21.35.07.881.0 ]--
r 65         return nu
--[ 2022.11.11.21.35.08.124.0 ]--
r 65         return nul
--[ 2022.11.11.21.35.08.231.0 ]--
r 65         return null
--[ 2022.11.11.21.35.08.611.0 ]--
r 65         return null;
--[ 2022.11.11.21.35.17.289.0 ]--
r 63     public Point min() {
r 67     public Point max() {
--[ 2022.11.11.21.35.33.183.0 ]--
+ 31         
--[ 2022.11.11.21.35.33.464.0 ]--
r 31         i
--[ 2022.11.11.21.35.33.610.0 ]--
r 31         if
--[ 2022.11.11.21.35.43.782.0 ]--
r 31         if()
--[ 2022.11.11.21.35.43.991.0 ]--
r 31         if(i)
--[ 2022.11.11.21.35.44.225.0 ]--
r 31         if(is)
--[ 2022.11.11.21.35.44.547.0 ]--
r 31         if(isE)
--[ 2022.11.11.21.35.44.673.0 ]--
r 31         if(isEm)
--[ 2022.11.11.21.35.44.903.0 ]--
r 31         if(isEmp)
--[ 2022.11.11.21.35.45.146.0 ]--
r 31         if(isEmpt)
--[ 2022.11.11.21.35.45.378.0 ]--
r 31         if(isEmpty)
--[ 2022.11.11.21.35.46.039.0 ]--
r 31         if(isEmpty())
--[ 2022.11.11.21.36.04.198.0 ]--
r 31         if(isEmpty()) 
--[ 2022.11.11.21.36.04.388.0 ]--
r 31         if(isEmpty()) r
--[ 2022.11.11.21.36.04.531.0 ]--
r 31         if(isEmpty()) re
--[ 2022.11.11.21.36.04.697.0 ]--
r 31         if(isEmpty()) ret
--[ 2022.11.11.21.36.04.820.0 ]--
r 31         if(isEmpty()) retu
--[ 2022.11.11.21.36.05.028.0 ]--
r 31         if(isEmpty()) retur
--[ 2022.11.11.21.36.05.226.0 ]--
r 31         if(isEmpty()) return
--[ 2022.11.11.21.36.05.398.0 ]--
r 31         if(isEmpty()) return 
--[ 2022.11.11.21.36.05.547.0 ]--
r 31         if(isEmpty()) return n
--[ 2022.11.11.21.36.05.739.0 ]--
r 31         if(isEmpty()) return nu
--[ 2022.11.11.21.36.05.967.0 ]--
r 31         if(isEmpty()) return nuo
--[ 2022.11.11.21.36.06.092.0 ]--
r 31         if(isEmpty()) return nuoo
--[ 2022.11.11.21.36.06.620.0 ]--
r 31         if(isEmpty()) return nuo
--[ 2022.11.11.21.36.07.600.0 ]--
r 31         if(isEmpty()) return nu
--[ 2022.11.11.21.36.08.252.0 ]--
r 31         if(isEmpty()) return nu;
--[ 2022.11.11.21.36.08.428.0 ]--
r 31         if(isEmpty()) return nu;;
--[ 2022.11.11.21.36.09.037.0 ]--
r 31         if(isEmpty()) return nu;
--[ 2022.11.11.21.36.09.186.0 ]--
r 31         if(isEmpty()) return nu
--[ 2022.11.11.21.36.09.724.0 ]--
r 31         if(isEmpty()) return nul
--[ 2022.11.11.21.36.10.391.0 ]--
r 31         if(isEmpty()) return null;
--[ 2022.11.11.21.37.30.547.0 ]--
+ 40         
--[ 2022.11.11.21.37.32.551.0 ]--
r 40         if(isEmpty()) return null;
